---
title: "Producing the Neighborhood Data Repository"
author: "Aaron Flicker"
format: 
  html:
    link-external-newwindow: true
    df-print: paged
    code-fold: true
editor: visual
---

# Importing Census data

The bulk of the data contained in the neighborhood repository comes from the Census Bureau's American Community Survey, and is accessed through an API using the tidycensus package. As of this writing, the most recently available five-year data is for the years 2018-22. A total of 127 variables will be accessed.

```{r}
#| warning: false
#| message: false
library(tidyverse)
library(tidycensus)

bg_var_list <-c(
  paste0("B01001_00", 1:9),
  paste0("B01001_0", 10:49),
  paste0("B02001_00", 2:9),
  "B02001_010",
  "B03002_012",
  paste0("B07201_00", c(1, 2, 4)),
  "B07201_014",
  paste0("B11012_00", 1:9),
  paste0("B11012_0", 10:17),
  "B15003_001",
  paste0("B15003_0", 17:25),
  paste0("B16004_00", c(1, 3, 7, 8)),
  paste0("B16004_0", c(12, 13, 17, 18, 22, 23, 25, 29, 30, 34, 35, 39, 
                       40, 44, 45, 47, 51, 52, 56, 57, 61, 62, 66, 67)),
  paste0("B17010_00", 1:2),
  "B19049_001",
  paste0("B25002_00", c(1, 3)),
  paste0("B27010_0", c(17, 33, 50, 66))
)

bg_vars <- load_variables("acs5", year = 2022) |>
  filter(name %in% bg_var_list) 
```

```{r}
#| echo: false
#| tbl-cap: "Sample of variables selected"
head(bg_vars)
```

## County subdivisions

For municipalities, the data are obtained at the county subdivision level for Butler, Clermont, Hamilton and Warren counties in Ohio; Boone, Campbell and Kenton counties in Kentucky; and Dearborn County in Indiana.

```{r}
#| warning: false
#| message: false
#| output: false

oh_muni <- get_acs(
  geography = "county subdivision",
  variables = c(bg_var_list, "B19058_002"),
  county = c("Hamilton", "Clermont", "Butler", "Warren"),
  state = "OH",
  year = 2022,
  geometry = TRUE#<1>
) 

ky_muni <- get_acs(
  geography = "county subdivision",
  variables = c(bg_var_list, "B19058_002"),
  county = c("Boone", "Campbell", "Kenton"),
  state = "KY",
  year = 2022,
  geometry = TRUE#<1>
) 

in_muni <- get_acs(
  geography = "county subdivision",
  variables = c(bg_var_list, "B19058_002"),
  county = "Dearborn",
  state = "IN",
  year = 2022,
  geometry = TRUE#<1>
) 

```

1.  The geometry = TRUE argument obtains the geographic boundaries of the municipalities. These will be used to build the map later on.

The data from the three states are then placed in one data frame. Because the Ohio municipalities of Fairfield, Loveland, and Milford cross county lines, they are split into multiple census subdivisions. These must be combined to obtain totals for the municipality.

```{r}
#| message: false
oki_muni <- rbind(oh_muni, ky_muni) |>
  rbind(in_muni) |>
  separate_wider_delim(
    NAME,
    names = c("Municipality", "County", "State"),
    delim = ", "
  ) |>
  mutate(
    Municipality = str_remove(Municipality, " city"),
    Municipality = str_remove(Municipality, " CCD"),
    Municipality = str_remove(Municipality, " village"),
    Municipality = str_remove(Municipality, "The Village of "),
    Municipality = str_to_title(Municipality),
    County = str_remove(County, " County")
  )|>
  select(-State)

oki_muni2 <- as_tibble(oki_muni) |>
  filter(variable != "B19049_001") |> 
  mutate(County = case_when(
    Municipality == "Loveland" ~ "Hamilton",
    Municipality == "Milford" ~ "Clermont",
    Municipality == "Fairfield" ~ "Butler",
    TRUE ~ County
    )
  ) |> 
  select(Municipality:estimate) |>
  left_join(bg_vars, by = c("variable" = "name")) |>
  group_by(Municipality, County, variable, label, concept) |>
  summarise(estimate = sum(estimate)) |>
  mutate(Neighborhood = Municipality) |>
  ungroup()
```

1.  Median household income is excluded from this grouping because it is a median, not a count.
2.  County must be included as a grouping factor because some townships in different counties have the same name.

```{r}
#| echo: false
#| tbl-cap: "Municipality totals"
head(oki_muni2)
```

## Cincinnati neighborhoods

To calculate totals for Cincinnati neighborhoods, data for Hamilton County must be obtained at the block group level. Block groups are then assigned to neighborhoods using a crosswalk derived from the city's [Statistical Neighborhood Approximations](https://www.cincinnati-oh.gov/planning/maps-and-data/census-demographics/2020-census-data/), which define which census tracts and block groups between to each neighborhood, and the University of Missouri's [Census Data Center](https://mcdc.missouri.edu/applications/geocorr.html), which provides a crosswalk between census tracts and municipalities.

For block groups that cross municipal boundaries, the Census Data Center estimates the share of each block group that belongs to each municipality. These shares are multiplied by the Census estimates for each block group to estimate neighborhood totals. For example, about 62% of block group 390610046023 is in Mt. Washington, with the rest in Anderson Township. To estimate the totals for Mt. Washington, the totals for this block group are multiplied by the share of it that is in Cincinnati.

```{r}
#| message: false
allocations <- read.csv(
  "neighborhood bg allocations.csv",
  colClasses = c(
    "character", 
    rep("NULL", 3), 
    "character", 
    "numeric", 
    "character"
  )
) |>
  mutate(
    Neighborhood = ifelse(
      Neighborhood %in% c("North Avondale", "Paddock Hills"),
      "North Avondale-Paddock Hills",
      Neighborhood
    )
  )

hamco_bg <- get_acs(
  geography = "block group",
  variables = bg_var_list,
  county = "Hamilton",
  state = "OH",
  year = 2022
) |>
  inner_join(bg_vars, by = c("variable" = "name"))

hamco_bg2 <- filter(hamco_bg, variable != "B19049_001") |> #<1>
  inner_join(allocations, multiple = "all") |>
  mutate(estimate = estimate*Allocation) |>
  filter(!is.na(estimate))

```

1.  Again, median household income is excluded.

The block groups within Cincinnati are then combined into neighborhoods, and the neighborhood totals added to a data frame with the municipal data.

```{r}
#| message: false
cinci_bg <- filter(hamco_bg2, Municipality == "Cincinnati")

cinci_hood <- cinci_bg |>
  as_tibble() |>
  group_by(Municipality, Neighborhood, variable, label, concept) |>
  summarise(estimate = sum(estimate)) |>
  mutate(County = "Hamilton")

hood_muni <- rbind(cinci_hood, oki_muni2) |>
  separate_wider_delim(
    label,
    names = paste0("Group", 1:5),
    delim = ":!!",
    too_few = "align_start"
  ) |>
  mutate(Neighborhood = coalesce(Neighborhood, Municipality))

```

```{r}
#| echo: false
#| tbl-cap: "Neighborhood totals"
head(hood_muni)
```

An example of each of the charts for the map will be created for each municipality and neighborhood. To ensure the right graphic goes with the right region on the map, these must be created in the proper order. To ensure a consistent order each neighborhood and municipality is assigned a number.

```{r}
areas <- hood_muni |>
  ungroup() |>
  distinct(County, Municipality, Neighborhood) |>
  arrange(str_to_title(Neighborhood), County) |> #<1>
  mutate(HoodID = row_number())
```

1.  str_to_title is needed to place the CUF neighborhood in proper alphabetical order, ignoring capitalization.

```{r}
#| echo: false
#| tbl-cap: "Area municipalities and neighborhoods"
head(areas)
```

# Demographics

The Demographics chart will include data on race, ethnicity, and household language. The relevant variables will be selected and totaled by municipality or neighborhood.

Race/ethnicity and language are grouped separately because the rates to be calculated use different denominators. For race and ethnicity, the totals will be compared to the entire population, while for language use the reference group is the population at least 5 years old.

Because several different reference populations will be used in our graphics, and some of them more than once, it will be useful to put the reference variables in their own data frame.

```{r}
pops <- hood_muni |> 
  filter(
    str_ends(variable, "_001"),
    str_detect(concept, "Income", negate = TRUE)
  ) |>
  mutate(
    Measure = case_when(
      str_starts(concept, "Sex") ~ "Population",
      str_starts(concept, "Geographical") ~ "Mobility",
      str_starts(concept, "Households") ~ "HH",
      str_starts(concept, "Educational") ~ "Over25",
      str_starts(concept, "Age") ~ "Over5",
      str_starts(concept, "Poverty") ~ "Poverty",
      TRUE ~ "HousingUnits"
    )
  ) |>
  pivot_wider(
    id_cols = c(County, Municipality, Neighborhood),
    names_from = Measure,
    names_prefix = "Pop",
    values_from = estimate
  )
```

```{r}
#| echo: false
#| tbl-cap: "Reference populations"
head(pops)
```

Once the race and language data are totaled, the proportions of the relevant population that belong to those groups are calculated.

```{r}
#| message: false
race <- filter(hood_muni, str_detect(concept, "Race")) |>
  mutate(
    Race = case_when(
      str_detect(Group2, "White") ~ "White",
      str_detect(Group2, "Black") ~ "Black",
      str_detect(Group2, "Hispanic") ~ "Hispanic",
      TRUE ~ "Other"
    )
  ) |>
  group_by(County, Municipality, Neighborhood, Race) |>
  summarise(Total = sum(estimate)) |>
  filter(Race != "Other") |>
  pivot_wider(
    id_cols = c(County, Municipality, Neighborhood),
    names_from = Race,
    names_prefix = "Total",
    values_from = Total
  ) |>
  inner_join(pops) |>
  mutate(
    RateBlack = TotalBlack/PopPopulation,
    RateWhite = TotalWhite/PopPopulation,
    RateHispanic = TotalHispanic/PopPopulation
  ) |>
  select(County: PopPopulation, RateBlack:RateHispanic)

lang <- filter(hood_muni, str_detect(concept, "Language")) |>
  mutate(
    Language = case_when(
      is.na(Group2) ~ "Total",
      str_detect(Group3, "English") ~ "English",
      TRUE ~ "NotWell"
    )
  ) |>
  filter(Language != "Total") |>
  group_by(Neighborhood, Municipality, County, Language) |>
  summarise(estimate = sum(estimate)) |>
  pivot_wider(
    id_cols = c(Neighborhood, Municipality, County),
    names_from = Language,
    names_prefix = "Total",
    values_from = estimate
  ) |>
  inner_join(pops) |>
  mutate(
    TotalOtherThanEnglish = PopOver5 - TotalEnglish,
    RateOtherThanEnglish = TotalOtherThanEnglish/PopOver5,
    RateNotWell = TotalNotWell/PopOver5
  ) |>
  select(
    Neighborhood:County, 
    TotalNotWell, 
    PopOver5, 
    TotalOtherThanEnglish:RateNotWell
  )
  
```

```{r}
#| echo: false
#| tbl-cap: "Population by race and ethnicity"
head(race)
```

To put the rates for each neighborhood in context, the aggregate rate in each variable for the metropolitan area will be calculated, along with the highest and lowest rates in an individual neighborhood. Each individual neighborhood's rates can then be compared to these benchmarks.

When calculating the means, Cincinnati neighborhood totals are excluded; Cincinnati is included as a municipality, so including the neighborhoods would result in double-counting.

Because this will be done for many graphics, writing a function creates a process that can be followed each time.

```{r}
benchmarks <- function(k){
  x <- filter(k, Municipality == Neighborhood) |>
    ungroup()
  baseline <- select(x, starts_with("Pop")) 
  baseline <- sum(baseline[1])
  means <- select(x, starts_with("Total")) |>
    summarise(across(everything(), sum)) |>
    mutate(across(everything(), \(x) x/baseline)) |>
    pivot_longer(cols = everything()) |>
    mutate(
      name = str_remove(name, "Total"),
      Measure = "Mean"
    )
  
  mins <- ungroup(k) |>
    select(starts_with("Rate")) |>
    summarise(across(everything(), min)) |>
    pivot_longer(cols = everything()) |>
    mutate(
      name = str_remove(name, "Rate"),
      Measure = "Min"
    )
  
  maxes <- ungroup(k) |>
    select(starts_with("Rate")) |>
    summarise(across(everything(), max)) |>
    pivot_longer(cols = everything()) |>
    mutate(
      name = str_remove(name, "Rate"),
      Measure = "Max"
    ) 
  
  y <- rbind(means, mins) |>
    rbind(maxes) |>
    pivot_wider(
      id_cols = name,
      names_from = Measure,
      values_from = value
    )
  
  z <- select(k, c(County:Neighborhood, starts_with("Rate"))) |>
    pivot_longer(
      cols = starts_with("Rate"),
    ) |>
    mutate(name = str_remove(name, "Rate")) |>
    inner_join(y) |>
    mutate(
      Shade = ifelse(
        value > Mean, 
        (value-Mean)/(Max-Mean), 
        (value-Mean)/(Mean-Min)
      ),
      Shade = ifelse(is.infinite(Shade), NA, Shade),
      Textloc = ifelse(value > .9, value - .025, value + .04)
    )
}
```

This function is used to calculate the minimums, maximums and means for the race and language data sets.

```{r}
#| message: FALSE
race_rates <- benchmarks(race)

lang_rates <- benchmarks(lang)

race_lang <- rbind(race_rates, lang_rates) |>
  mutate(Neighborhood = coalesce(Neighborhood, Municipality)) |>
  inner_join(areas)

```

```{r}
#| echo: false
#| tbl-cap: "Data frame for creating the Demographics charts"
head(race_lang)
```

With the data frame now ready, a function will be created to create the graphics. Another function will iterate over the list of ID numbers for neighborhoods and municipalities, creating a graphic for each area. Because the municipalities of Norwood, St. Bernard and Elmwood Place are surrounded by Cincinnati, they will be included on both the municipality and neighborhood lists.

```{r}

cchmcdarkpurple <- "#83286B"
cchmcdarkgreen <- "#76BC44"
cchmclightblue <- "#9BD3DD"

demo_graph <- function(k) {
  x <- filter(race_lang, HoodID == k) |>
    mutate(
      name = factor(
        name, 
        levels = c("White", "Black", "Hispanic",  "OtherThanEnglish", "NotWell")
      )
    )
  
  ggplot(x, aes(x = name, y = value, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = seq(0, 1, .2),
      labels = seq(0, 100, 20)
    ) +
    scale_x_discrete(
      labels = c(
        "White",
        "Black",
        "Hispanic",
        "Language other\nthan English",
        "Limited\nEnglish"
      )
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = .5),
      legend.position = c(.9, .8)
    ) + 
    geom_text(
      aes(label = paste0(round(value*100, 1), "%"), y = Textloc), 
      size = 4
    ) +
    scale_fill_gradient2(
      limits = c(-1, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Lowest", "Average", "Highest")
    )
}

muninums <- areas$HoodID[areas$Neighborhood == areas$Municipality]

hoodnums <- areas$HoodID[areas$Municipality%in% c(
  "Cincinnati", 
  "Norwood", 
  "St. Bernard", 
  "Elmwood Place"
) & areas$Neighborhood != "Cincinnati"]

demo_popup_muni <- lapply((muninums), function(k) {
  demo_graph(k)
})

demo_popup_hood <- lapply((hoodnums), function(k) {
  demo_graph(k)
})
```

```{r}
#| echo: false
#| fig-cap: "Area demographics"
x <- filter(race_lang, HoodID == 20) |>
    mutate(
      name = factor(
        name, 
        levels = c("White", "Black", "Hispanic",  "OtherThanEnglish", "NotWell")
        )
      )
  
  ggplot(x, aes(x = name, y = value, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = seq(0, 1, .2),
      labels = seq(0, 100, 20)
    ) +
    scale_x_discrete(
      labels = c(
        "White",
        "Black",
        "Hispanic",
        "Language other\nthan English",
        "Limited\nEnglish"
      )
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = .5),
      legend.position = c(.9, .8)
      ) + 
    geom_text(
      aes(label = paste0(round(value*100, 1), "%"), y = Textloc), 
      size = 4
    ) +
    scale_fill_gradient2(
      limits = c(-1, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Lowest", "Average", "Highest")
    )
```

# Deprivation Indicators

The [Deprivation Index](https://geomarker.io/dep_index/), created by Brokamp et al., uses six different ACS measures to capture community deprivation in one variable. The Deprivation Indicators graphic will chart the Deprivation Index for each neighborhood, along with each of its six component measures.

The first input is a list of the Deprivation Indexes for all the census tracts in the United States.

```{r}
di <- read.csv(
  "deprivation index all tracts 2022.csv",
  colClasses = c("numeric", "character", rep("NULL", 6))
)
```

```{r}
#| echo: false
#| tbl-cap: "Deprivation Index by census tract"
head(di)
```

Each value is a number between 0 and 1, with higher values representing more deprivation.

Because the Deprivation Index is calculated at the census tract level, the values for neighborhoods and municipalities must be interpolated. For each area, the Deprivation Index will be a weighted average of the indexes of the census tracts within its boundaries, weighted by population.

For Cincinnati neighborhoods, the block group data already used can be rolled up to the tract level.

```{r}
#| message: false
hood_di <- filter(cinci_bg, variable == "B01001_001") |>
  as_tibble() |>
  mutate(census_tract_fips = str_trunc(GEOID, 11, "right", ellipsis = "")) |>
  group_by(census_tract_fips, Neighborhood, Municipality) |>
  summarise(Population = sum(estimate)) |>
  group_by(Municipality, Neighborhood) |>
  mutate(
    HoodPop = sum(Population),
    TractWeight = Population/HoodPop
  ) |>
  inner_join(di) |>
  mutate(DIWeight = TractWeight*dep_index) |>
  summarise(DeprivationIndex = sum(DIWeight)) |>
  mutate(County = "Hamilton")
```

```{r}
#| echo: false
#| tbl-cap: "Deprivation Index by neighborhood"
head(hood_di)
```

For other municipalities, tract-level populations must be obtained for the eight-county area.

```{r}
#| message: false

oh_tract <- get_acs(
  geography = "tract",
  variables = "B01001_001",
  state = "OH",
  county = c("Clermont", "Warren", "Butler", "Hamilton"),
  year = 2022
)

ky_tract <- get_acs(
  geography = "tract",
  variables = "B01001_001",
  state = "KY",
  county = c("Kenton", "Campbell", "Boone"),
  year = 2022
)

in_tract <- get_acs(
  geography = "tract",
  variables = "B01001_001",
  state = "IN",
  county = "Dearborn",
  year = 2022
)
```

A crosswalk from the Census Data Center estimates the share of each census tract that is in each municipality. This is used to estimate the populations in tracts that cross municipal lines.

```{r}
#| message: false
oki <- read.csv(
  "oki allocations.csv",
  col.names = c(
    "CountyCode",
    "Tract",
    NA,
    "County",
    "Municipality",
    NA,
    "Allocation"
  ),
  colClasses = c(
    "character", 
    "character", 
    "NULL", 
    "character", 
    "character", 
    "NULL", 
    "numeric"
  )
) |>
  filter(
    County %in% c(
      "Dearborn IN",
      "Boone KY",
      "Campbell KY",
      "Kenton KY",
      "Butler OH",
      "Clermont OH",
      "Hamilton OH",
      "Warren OH"
    )
  ) |>
  separate_wider_delim(
    Municipality, delim = "CCD", names = "Municipality", too_many = "drop"
  ) |>
  separate_wider_delim(
    Municipality, delim = " city", names = "Municipality", too_many = "drop"
  ) |>
  separate_wider_delim(
    Municipality, delim = ",", names = "Municipality", too_many = "drop"
  )|>
  separate_wider_delim(
    Municipality, delim = "village", names = "Municipality", too_many = "drop"
  ) |>
  separate_wider_delim(
    Tract, 
    delim = ".", 
    names = c("TractA", "TractB"),
    too_few = "align_start"
  ) |>
  mutate(
    Municipality = str_remove(Municipality, "The Village of"),
    Municipality = str_to_title(Municipality),
    Municipality = str_trim(Municipality),
    Tract = NA
  ) |>
  separate_wider_delim(County, delim = " ", names = c("County", "State")) |>
  mutate(
    State = case_when(
      State == "OH" ~ "Ohio",
      State == "KY" ~ "Kentucky",
      TRUE ~ "Indiana"
    ),
    TractB = coalesce(TractB, "")
  )

for (i in 1:nrow(oki)){
  if (str_length(oki$TractA[i]) < 4){
    prefix_length <- 4-str_length(oki$TractA[i])
    prefix <- str_flatten(rep("0", prefix_length))
  }else{
    prefix_length = 0
    prefix = ""
  }
  suffix_length <-
    6-prefix_length-str_length(oki$TractA[i])-str_length(oki$TractB[i])
  suffix <- str_flatten(rep("0", suffix_length))
  oki$Tract[i] <- paste0(prefix, oki$TractA[i], oki$TractB[i], suffix)
}
oki$GEOID <- paste0(oki$CountyCode, oki$Tract)

dep_index <- rbind(oh_tract, ky_tract) |>
  rbind(in_tract) |>
  full_join(select(oki, County:Allocation, GEOID), multiple = "all") |>
  mutate(Population = estimate*Allocation) |>
  inner_join(
    select(di, census_tract_fips, dep_index), 
    by = c("GEOID" = "census_tract_fips")
  ) |>
  mutate(
    County = case_when(
      Municipality == "Loveland" ~ "Hamilton",
      Municipality == "Milford" ~ "Clermont",
      TRUE ~ County
    )
  ) |>
  group_by(Municipality, County) |>
  mutate(
    TownPop = sum(Population),
    TractShare = Population/TownPop,
    DIWeight = TractShare*dep_index
  ) |>
  summarise(DeprivationIndex = sum(DIWeight)) |>
  mutate(Neighborhood = Municipality) |>
  rbind(hood_di) |>
  rename(value = DeprivationIndex) |>
  mutate(name = "DI")
```

```{r}
#| echo: false
#| tbl-cap: "Deprivation Index by municipality"
head(dep_index)
```

The Deprivation Index comprises six measures:

-   Poverty rate

-   Rate of families on public assistance

-   Median household income

-   Proportion of individuals lacking health insurance

-   High school graduation rate among those at least 25 years old

-   Housing vacancy rate

## Public assistance rate

The public assistance rate is not available at the block group level, so for Cincinnati neighborhoods, the data must be obtained at the tract level and interpolated to the neighborhood level based on the number of households in each tract. These totals can be added to the municipal totals already obtained.

```{r}
#| message: false
cinci_hh <- filter(hamco_bg2, variable == "B11012_001") |>
  mutate(TractID = str_trunc(GEOID, 11, "right", ellipsis = "")) |>
  group_by(TractID) |>
  mutate(TractHH = sum(estimate)) |>
  group_by(Neighborhood, Municipality, TractID) |>
  mutate(HoodTractHH = sum(estimate)) |>
  distinct(TractID, Neighborhood, TractHH, HoodTractHH) |>
  mutate(Allocation = HoodTractHH/TractHH) |>
  select(Allocation) |>
  ungroup() |>
  filter(Municipality == "Cincinnati")

hood_assistance <- get_acs(
  geography = "tract",
  variables = c("B19058_002", "B11012_001"),
  county = "Hamilton",
  state = "OH"
) |>
  mutate(
    Category = ifelse(variable == "B11012_001", "PopHH", "TotalAssistance")
  ) |>
  pivot_wider(
    id_cols = GEOID,
    names_from = Category,
    values_from = estimate
  ) |>
  inner_join(cinci_hh, by = c("GEOID" = "TractID"), multiple = "all") |>
  mutate(across(PopHH:TotalAssistance, \(x) x*Allocation)) |>
  group_by(Municipality, Neighborhood) |>
  summarise(across(PopHH:TotalAssistance, sum)) |>
  mutate(County = "Hamilton")

assistance <- filter(hood_muni, variable %in% c("B19058_002", "B11012_001")) |>
  filter(Neighborhood == Municipality) |>
  mutate(
    Category = ifelse(variable == "B11012_001", "PopHH", "TotalAssistance")
  ) |>
  pivot_wider(
    id_cols = c(County, Municipality, Neighborhood),
    names_from = Category,
    values_from = estimate
  ) |>
  rbind(hood_assistance) |>
  mutate(
    value = TotalAssistance/PopHH,
    name = "Assistance"
  ) |>
  select(County:Neighborhood, value, name)
```

```{r}
#| echo: false
#| tbl-cap: "Public assistance rate"
head(assistance)
```

## Median household income

The median household income must be handled differently from other metrics because it is not a proportion. The neighborhood median income is estimated in the following manner:

-   For each census block group for which income data are available, multiply the median household income by the number of households.

-   Total this figure and the number of households at the neighborhood level.

-   Divide the neighborhood income figure by the number of households in the neighborhood.

This creates a weighted average of the median household incomes in each of the block groups in the neighborhood. While this is not mathematically proper for calculating a median, it is likely the best available method for making an estimate.

```{r}
#| message: false
hood_income <- filter(hamco_bg, variable %in% c("B11012_001", "B19049_001")) |>
  as_tibble() |>
  mutate(Category = ifelse(variable == "B19049_001", "MedianIncome", "HH")) |>
  inner_join(allocations, multiple = "all") |>
  mutate(estimate = ifelse(Category == "HH", estimate*Allocation, estimate)) |>
  pivot_wider(
    id_cols = c(Municipality, Neighborhood, GEOID),
    names_from = Category,
    values_from = estimate
  ) |>
  filter(
    Municipality == "Cincinnati",
    !is.na(MedianIncome)
  ) |>
  mutate(Income = MedianIncome*HH) |>
  group_by(Municipality, Neighborhood) |>
  summarise(
    Income = sum(Income),
    HH = sum(HH)
  ) |>
  mutate(
    value = Income/HH,
    County = "Hamilton"
  ) |>
  select(County, Neighborhood, value)
```

For the municipalities that cross county lines, a weighted average of the municipality's county subdivisions is taken. The municipal and neighborhood income data are then combined into one data frame.

```{r}
#| message: false
oki_income <- oki_muni |>
  filter(variable %in% c("B11012_001", "B19049_001")) |>
  mutate(Category = ifelse(variable == "B19049_001", "MedianIncome", "HH")) |>
  pivot_wider(
    id_cols = c(GEOID, Municipality, County),
    names_from = Category,
    values_from = estimate
  ) |>
  filter(!is.na(MedianIncome)) |>
  mutate(
    Income = MedianIncome*HH,
    County = case_when(
      Municipality == "Loveland" ~ "Hamilton",
      Municipality == "Fairfield" ~ "Butler",
      Municipality == "Milford" ~ "Clermont",
      TRUE ~ County
    )
  ) |>
  group_by(Municipality, County) |>
  summarise(
    HH = sum(HH),
    Income = sum(Income)
  ) |>
  mutate(
    value = Income/HH,
    Neighborhood = Municipality
  ) |>
  select(-c(HH, Income)) |>
  rbind(hood_income) |>
  mutate(name = "MedianIncome")
```

```{r}
#| echo: false
#| tbl-cap: "Median household income"
head(oki_income)
```

## Other measures

The remaining Deprivation Index inputs are more straightforward because they are simply proportions using data available at the block group level.

```{r}
#| message: false
di_meas <- hood_muni |>
  filter(variable %in% c(paste0("B15003_0", 17:25), "B17010_002", "B25002_003") |
           str_detect(variable, "B27010")) |>
  mutate(
    Category = case_when(
      str_starts(concept, "Educational") ~ "NoHighSchool",
      str_starts(concept, "Poverty") ~ "Poverty",
      str_starts(concept, "Occupancy") ~ "Vacant",
      TRUE ~ "Uninsured"
    )
  ) |>
  group_by(Municipality, County, Neighborhood, Category) |>
  summarise(estimate = sum(estimate)) |>
  pivot_wider(
    id_cols = c(Municipality, County, Neighborhood),
    names_from = Category,
    names_prefix = "Total",
    values_from = estimate
  ) |>
  inner_join(pops)

pov <- select(di_meas, ends_with("Poverty")) |>
  mutate(
    value = TotalPoverty/PopPoverty,
    name = "Poverty"
  ) |>
  select(-c(TotalPoverty, PopPoverty))

ins <- select(di_meas, TotalUninsured, PopPopulation) |>
  mutate(
    value = TotalUninsured/PopPopulation,
    name = "Uninsured"
  ) |>
  select(value, name)

hs <- select(di_meas, Municipality:TotalNoHighSchool, PopOver25) |>
  mutate(
    value = TotalNoHighSchool/PopOver25,
    name = "NoHS"
  ) |>
  select(Municipality:Neighborhood, name, value)

vac <- di_meas |>
  mutate(
    value = TotalVacant/PopHousingUnits,
    name = "Vacancy"
  ) |>
  select(Municipality:Neighborhood, name, value)
```

The Deprivation Index and its components are expressed in different units. Median household income is in dollars, while the other metrics are percentages, and the index itself is on a 0-1 scale. Displaying all of these on the same graph requires converting them all to the same scale.

Each metric will be plotted so that the minimum value is scaled to 0, and maximum value is scaled to 1, and all other values are scaled proportionally based on their z-scores. Because this will be done for all six metrics, a function allows the process to be repeated efficiently.

```{r}
#| message: false
digraph_rates <- function(k, var){
  z <- filter(hood_muni, variable == var) |>
    inner_join(k) |>
    filter(Neighborhood == Municipality) |>
    mutate(Weight = value*estimate) |>
    ungroup() |>
    summarise(
      Weight = sum(Weight),
      Pop = sum(estimate)
    ) |>
    mutate(
      Mean = Weight/Pop,
      Min = min(k$value),
      Max = max(k$value),
      SD = sd(k$value)
    ) |>
    select(Mean:SD) |>
    cross_join(k) |>
    mutate(
      ZScore = (value-Mean)/SD,
      Scale = ifelse(
        ZScore > 0, 
        ((ZScore/max(ZScore))+1)/2, 
        (-ZScore/min(ZScore)+1)/2
      ),#<1>
      Textloc = ifelse(Scale > .9, Scale - .025, Scale + .04)
    )
}

di_rates <- digraph_rates(dep_index, "B01001_001") |>
  mutate(Shade = -(Scale-1))#<2>

income_rates <- digraph_rates(oki_income, "B11012_001") |>
  mutate(Shade = Scale)#<2>

pov_rates <- digraph_rates(pov, "B17010_001") |>
  mutate(Shade = -(Scale-1))#<2>

ins_rates <- digraph_rates(ins, "B01001_001") |>
  mutate(Shade = -(Scale-1))#<2>

assist_rates <- digraph_rates(assistance, "B11012_001") |>
  mutate(Shade = -(Scale-1))#<2>

hs_rates <- digraph_rates(hs, "B15003_001") |>
  mutate(Shade = Scale)#<2>

vac_rates <- digraph_rates(vac, "B25002_001") |>
  mutate(Shade = -(Scale-1))#<2>

di_all <- rbind(di_rates, pov_rates) |>
  rbind(assist_rates) |>
  rbind(income_rates) |>
  rbind(ins_rates) |>
  rbind(hs_rates) |>
  rbind(vac_rates) |>
  inner_join(areas)
```

1.  The height of the bars on the graph will be determined by the z-score of each measure, with the average value in the middle. Values are scaled proportionally based on the distance from the maximum or minimum z-score and a z-score of 0.
2.  Color is proportional to the height of the bars, but with the color palette depending on whether a higher or lower value is desirable for that metric. Better values will show up as green, while worse ones will be purple.

The data are now ready for graphing, and a function creates the graphs in a similar manner to the Demographic charts.

```{r}
di_graph <- function(k){
  x <- filter(di_all, HoodID == k) 
  if (nrow(x) < 7){
    x <- rbind(
      x, 
      c(
        as.numeric(rep(NA, 4)), 
        as.character(x[1, 5:6]),
        NA,
        as.character(x[1, 8]),
        "MedianIncome",
        NA,
        0,
        .04,
        0,
        mean(x$HoodID)
      )
    )
    x <- x |>
      mutate(across(c(Mean:SD, value, ZScore:Shade), as.numeric))
  } #<1>
  x <- x |>
    mutate(
      name = factor(
        name,
        levels = c(
          "DI",
          "Poverty",
          "Assistance",
          "MedianIncome",
          "Uninsured",
          "NoHS",
          "Vacancy"
        )
      ),
      Label = case_when(
        is.na(value) ~ "NA",
        name == "DI" ~ as.character(round(value, 3)),
        name == "MedianIncome" ~ 
          paste0("$", format(as.integer(value), big.mark = ",")),
        TRUE ~ paste0(round(value*100, 1), "%")
      )
    )
  
  ggplot(x, aes(x = name, y = Scale, fill = Shade)) +
    geom_bar(stat = "identity") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = c(0, .5, 1),
      labels = c("Lowest", "Average", "Highest")
    ) +
    scale_x_discrete(
      labels = c(
        "Deprivation\nIndex",
        "Poverty\nRate",
        "On Public\nAssistance",
        "Median\nHousehold\nIncome",
        "No Health\nInsurance",
        "High School\nGraduation",
        "Housing\nVacancies"
      )
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = .5),
      legend.position = "bottom"
    ) + 
    geom_text(aes(label = Label, y = Textloc), size = 4) +
    scale_fill_gradient2(
      limits = c(0, 1), 
      high = cchmcdarkgreen, 
      low = cchmcdarkpurple,
      mid = cchmclightblue,
      midpoint = .5,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Worst", "Average", "Best")
    )
}

di_popup_muni <- lapply((muninums), function(k) {
  di_graph(k)
})

di_popup_hood <- lapply((hoodnums), function(k) {
  di_graph(k)
})
```

1.  Median household income is unavailable for some areas, so a null value must be added to the data set if necessary.

```{r}
#| echo: false
#| fig-cap: "Deprivation indicators"
 x <- filter(di_all, HoodID == 30) |>
    mutate(
      name = factor(
        name,
        levels = c(
          "DI",
          "Poverty",
          "Assistance",
          "MedianIncome",
          "Uninsured",
          "NoHS",
          "Vacancy"
          )
        ),
      Label = case_when(
        is.na(value) ~ "NA",
        name == "DI" ~ as.character(round(value, 3)),
        name == "MedianIncome" ~ 
          paste0("$", format(as.integer(value), big.mark = ",")),
        TRUE ~ paste0(round(value*100, 1), "%")
        )
      )
  
ggplot(x, aes(x = name, y = Scale, fill = Shade)) +
    geom_bar(stat = "identity") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = c(0, .5, 1),
      labels = c("Lowest", "Average", "Highest")
    ) +
    scale_x_discrete(
      labels = c(
        "Deprivation\nIndex",
        "Poverty\nRate",
        "On Public\nAssistance",
        "Median\nHousehold\nIncome",
        "No Health\nInsurance",
        "High School\nGraduation",
        "Housing\nVacancies"
      )
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = .5),
      legend.position = "bottom"
      ) + 
    geom_text(aes(label = Label, y = Textloc), size = 4) +
    scale_fill_gradient2(
      limits = c(0, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen,
      mid = cchmclightblue,
      midpoint = .5,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Worst", "Average", "Best")
    )
```

# Age and gender

The age categories used by the American Community Survey vary in duration, so some variables need to be combined in order to create 5-year windows.

```{r}
#| message: false
pyramid <- filter(hood_muni, concept == "Sex by Age") |>
  ungroup() |>
  filter(!is.na(Group3)) |>
  rename(Gender = Group2) |>
  mutate(
    Age = str_remove(Group3, " years"),
    Age = case_when(
      Age %in% c("15 to 17", "18 and 19") ~ "15 to 19",
      Age %in% c("20", "21", "22 to 24") ~ "20 to 24",
      Age %in% c("60 and 61", "62 to 64") ~ "60 to 64",
      Age %in% c("65 and 66", "67 to 69") ~ "65 to 69",
      TRUE ~ Age
    ),
    Age = factor(
      Age, 
      levels = c(
        "Under 5",
        "5 to 9",
        "10 to 14",
        "15 to 19",
        "20 to 24",
        "25 to 29",
        "30 to 34",
        "35 to 39",
        "40 to 44",
        "45 to 49",
        "50 to 54",
        "55 to 59",
        "60 to 64",
        "65 to 69",
        "70 to 74",
        "75 to 79",
        "80 to 84",
        "85 and over"
      )
    )
  ) |>
  group_by(County, Municipality, Neighborhood, Gender, Age) |>
  summarise(Population = sum(estimate)) |>
  inner_join(areas) |>
  group_by(County, Municipality, Neighborhood) |>
  mutate(
    Total = sum(Population),
    Share = round(100*Population/Total, 1)
  ) 
```

```{r}
#| echo: false
#| tbl-cap: "Age and gender breakdown"
head(pyramid)
```

The graph shows the share of the area's population comprised by each age and gender group.

```{r}
cchmcpink <- "#E64479"
cchmclightblue <- "#9BD3DD"

pop_pyr <- function(k){
  x <- filter(pyramid, HoodID == k) |>
    mutate(Neighborhood = coalesce(Neighborhood, Municipality))
  
  ggplot(
    x, 
    aes(
      x = Age, 
      y = ifelse(Gender == "Male", -Share, Share), 
      fill = Gender
    )
  ) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(
      x = NULL, 
      y = "% of population", 
      fill = NULL, 
      title = x$Neighborhood[1]
    ) +
    scale_y_continuous(
      limits = c(-30, 30), 
      breaks = seq(-25, 25, 5),
      labels = c(25, 20, 15, 10, 5, seq(0, 25, 5))
    ) +
    scale_fill_manual(values = c(cchmcpink, cchmclightblue)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5))
}

pyr_popup_muni <- lapply((muninums), function(k) {
  pop_pyr(k)
})

pyr_popup_hood <- lapply((hoodnums), function(k) {
  pop_pyr(k)
})
```

```{r}
#| echo: false
#| fig-cap: "Age and gender breakdown"

x <- filter(pyramid, HoodID == 51) |>
    mutate(Neighborhood = coalesce(Neighborhood, Municipality))
  
  ggplot(
    x, 
    aes(
      x = Age, 
      y = ifelse(Gender == "Male", -Share, Share), 
      fill = Gender
      )
    ) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(
      x = NULL, 
      y = "% of population", 
      fill = NULL, 
      title = x$Neighborhood[1]
      ) +
    scale_y_continuous(
      limits = c(-30, 30), 
      breaks = seq(-25, 25, 5),
      labels = c(25, 20, 15, 10, 5, seq(0, 25, 5))
      ) +
    scale_fill_manual(values = c(cchmcpink, cchmclightblue)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5))
```

# Household Types

The Household Types chart consolidates 15 ACS variable into four broad categories: With or without children; and with one or more adults.

```{r}
#| message: false
hh <- filter(
  hood_muni, 
  variable %in% c(
    paste0("B11012_00", c(3, 4, 6, 7, 9)), 
    paste0("B11012_0", c(10:12, 14:17))
  )
) |>
  mutate(
    HHType = case_when(
      str_detect(Group2, "couple") ~ 
        ifelse(str_starts(Group3, "With children"), "TwoParent", "Couple"),
      TRUE ~ 
        ifelse(str_starts(Group3, "With children"), "SingleParent", "Single")
    )
  ) |>
  group_by(County, Municipality, Neighborhood, HHType) |>
  summarise(HH = sum(estimate)) |>
  ungroup() |>
  pivot_wider(
    id_cols = c(County, Municipality, Neighborhood),
    names_from = HHType,
    values_from = HH,
    names_prefix = "Total"
  ) |>
  inner_join(pops) |>
  mutate(
    RateCouple = TotalCouple/PopHH,
    RateSingle = TotalSingle/PopHH,
    RateSingleParent = TotalSingleParent/PopHH,
    RateTwoParent = TotalTwoParent/PopHH
  ) |>
  select(County:TotalTwoParent, PopHH, RateCouple:RateTwoParent)

hh_rates <- benchmarks(hh) |>
  inner_join(areas)

hh_graph <- function(k) {
  x <- filter(hh_rates, HoodID == k) |>
    mutate(
      name = factor(
        name, 
        levels = c("TwoParent", "SingleParent", "Couple", "Single")
      )
    )
  
  ggplot(x, aes(x = name, y = value, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = seq(0, 1, .2),
      labels = seq(0, 100, 20)
    ) +
    scale_x_discrete(
      labels = c(
        "Children with\ntwo adults",
        "Children with\none adult",
        "Adults,\nno children",
        "Single adult"
      )
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(
      aes(label = paste0(round(value*100, 1), "%"), y = Textloc), 
      size = 4
    ) +
    scale_fill_gradient2(
      limits = c(-1, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Lowest", "Average", "Highest")
    )
} 

hh_popup_muni <- lapply((muninums), function(k) {
  hh_graph(k)
})

hh_popup_hood <- lapply((hoodnums), function(k) {
  hh_graph(k)
})
```

```{r}
#| echo: false
#| fig-cap: "Household types breakdown"
x <- filter(hh_rates, HoodID == 30) |>
    mutate(
      name = factor(
        name, 
        levels = c("TwoParent", "SingleParent", "Couple", "Single")
      )
    )
  
  ggplot(x, aes(x = name, y = value, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = seq(0, 1, .2),
      labels = seq(0, 100, 20)
    ) +
    scale_x_discrete(
      labels = c(
        "Children with\ntwo adults",
        "Children with\none adult",
        "Adults,\nno children",
        "Single adult"
      )
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(
      aes(label = paste0(round(value*100, 1), "%"), y = Textloc), 
      size = 4
    ) +
    scale_fill_gradient2(
      limits = c(-1, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Lowest", "Average", "Highest")
    )
```

# Geographic Mobility

This chart shows the proportion of the population that moved in the previous year, either within the metropolitan area or from outside.

```{r}
#| message: false
mobile <- hood_muni |>
  filter(variable %in% c("B07201_002", "B07201_004", "B07201_014")) |>
  mutate(
    Category = case_when(
      str_starts(Group2, "Same") ~ "SameHome",
      !is.na(Group3) ~ "SameCity",
      TRUE ~ "Abroad"
    )
  ) |>
  group_by(Municipality, County, Neighborhood, Category) |>
  summarise(estimate = sum(estimate)) |>
  pivot_wider(
    id_cols = c(Municipality, County, Neighborhood),
    names_from = Category,
    names_prefix = "Total",
    values_from = estimate
  ) |>
  inner_join(pops) |>
  mutate(
    TotalOtherUS = PopMobility-TotalSameHome-TotalSameCity-TotalAbroad,
    RateSameHome = TotalSameHome/PopMobility,
    RateSameCity = TotalSameCity/PopMobility,
    RateOtherUS = TotalOtherUS/PopMobility,
    RateAbroad = TotalAbroad/PopMobility
  ) |>
  select(Municipality:TotalSameHome, PopMobility, TotalOtherUS:RateAbroad)

mobile_rates <- benchmarks(mobile) |>
  inner_join(areas)

mobile_graph <- function(k){
  x <- filter(mobile_rates, HoodID == k) |>
    mutate(
      name = factor(
        name, 
        levels = c("SameHome", "SameCity", "OtherUS",  "Abroad")
      )
    )
  
  ggplot(x, aes(x = name, y = value, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = seq(0, 1, .2),
      labels = seq(0, 100, 20)
    ) +
    scale_x_discrete(
      labels = c(
        "Same Home",
        "Same metro area",
        "Elsewhere\nin U.S.",
        "Other Country"
      )
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(
      aes(label = paste0(round(value*100, 1), "%"), y = Textloc), 
      size = 4
    ) +
    scale_fill_gradient2(
      limits = c(-1, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Lowest", "Average", "Highest")
    )
}

mobile_popup_muni <- lapply((muninums), function(k) {
  mobile_graph(k)
})

mobile_popup_hood <- lapply((hoodnums), function(k) {
  mobile_graph(k)
})
```

```{r}
#| echo: false
#| fig-cap: "Geographic mobility"

x <- filter(mobile_rates, HoodID == 42) |>
    mutate(
      name = factor(
        name, 
        levels = c("SameHome", "SameCity", "OtherUS",  "Abroad")
      )
    )
  
  ggplot(x, aes(x = name, y = value, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(x = NULL, y = "%", title = unique(x$Neighborhood), fill = NULL) +
    scale_y_continuous(
      limits = c(0, 1),
      breaks = seq(0, 1, .2),
      labels = seq(0, 100, 20)
    ) +
    scale_x_discrete(
      labels = c(
        "Same Home",
        "Same City",
        "Elsewhere\nin U.S.",
        "Other Country"
      )
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(
      aes(label = paste0(round(value*100, 1), "%"), y = Textloc), 
      size = 4
    ) +
    scale_fill_gradient2(
      limits = c(-1, 1), 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      breaks = waiver(),
      n.breaks = 3,
      labels = c("Lowest", "Average", "Highest")
    )
```

# Health Indicators

The definitions of asthma, type 1 diabetes, and psychiatric admissions are taken from the Cincinnati Children's Data Depot. Admissions data are for calendar years 2022 and 2023.

```{r}
#| message: false
#| warning: false
library(DBI)
library(odbc)

con <- dbConnect(odbc::odbc(), "ClarityProd")

registry <- dbGetQuery(con, "
  SELECT DISTINCT p.pat_id
                ,CAST(p.birth_date AS DATE) AS birth_date
				        ,p.add_line_1
				        ,p.add_line_2
				        ,p.city
				        ,p.state
				        ,p.zip
				        ,p.county
				        ,c.registry_id
				        ,c.registry_name
				        ,g.X
				        ,g.Y
				        ,g.foster
				        ,g.rmh
				        ,g.pobox
				        ,g.cchmc
				        ,g.stjoe
				        ,g.unknown_address
				        ,g.foreign_address
				        ,g.geocode_attempted
  FROM hpceclarity.bmi.registry_config c
    INNER JOIN hpceclarity.bmi.reg_data_hx_membership m
      ON c.registry_id = m.registry_id
    INNER JOIN hpceclarity.bmi.registry_data_info d
      ON m.record_id = d.record_id
    INNER JOIN hpceclarity.bmi.patient p
      ON p.pat_id = d.networked_id
    LEFT JOIN temptable.dbo.full_list_geocode g
      ON (p.add_line_1 = g.add_line_1 
          OR (p.add_line_1 IS NULL AND g.add_line_1 IS NULL))
        AND (p.add_line_2 = g.add_line_2 
          OR (p.add_line_2 IS NULL AND g.add_line_2 IS NULL))
        AND (p.city = g.city OR (p.city IS NULL AND g.city IS NULL))
        AND (p.state = g.state OR (p.state IS NULL AND g.state IS NULL))
        AND (p.zip = g. zip OR (p.zip IS NULL AND g.zip IS NULL))
  WHERE (c.registry_name LIKE '%asthma%' OR c.registry_id = '210652454')
    AND p.add_line_1 NOT LIKE '%222 E%'
    AND m.status_c = 1
    AND g.foster != 1
    AND g.rmh != 1
    AND g.pobox != 1
    AND g.cchmc != 1
    AND g.stjoe != 1
    AND g.unknown_address != 1
    AND g.foreign_address != 1
    AND g.state in ('Ohio', 'Kentucky', 'Indiana')
                  ") |>
  mutate(
    asthma_admission = 0,
    t1d_registry_admission = 0,
    mental_health_admission = 0,
    county = str_to_title(county),
    contact_date = today()
  ) |>
  mutate(Age = as.numeric(today()-birth_date)/365.25) |>
  filter(Age <= 18) 

asthma_exceptions <- dbGetQuery(con, "
  SELECT DISTINCT ha.hsp_account_id
                ,peh.pat_enc_csn_id
    FROM hpceclarity.bmi.hsp_acct_dx_list ha
      INNER JOIN hpceclarity.bmi.edg_current_icd10 edg
        ON ha.dx_id = edg.dx_id
      INNER JOIN hpceclarity.bmi.pat_enc_hsp peh
        ON ha.hsp_account_id = peh.hsp_account_id
    WHERE edg.code in ('E94.9', 'E84.8', 'E84.19', 'E84.0',
                       'E84.11', 'Z93.0', 'Z99.11', 'Z99.1') 
      OR (edg.code like 'D57.%' AND edg.code <> 'D57.3')
      OR edg.code like 'J96.1%'
      OR edg.code like 'J96.2%'
      OR edg.code like 'Q20.%'
      OR edg.code like 'Q24.%'
      OR edg.code like 'Q25.%'
      OR edg.code like 'Q89.3%'
                                ") |>
  mutate(AsthmaException = 1)

admits <- dbGetQuery(con, "
  SELECT DISTINCT r.pat_enc_csn_id
                  ,r.pat_id
                  ,CAST(r.birth_date AS DATE) AS birth_date
                  ,CAST(r.hosp_admsn_time AS DATE) AS contact_date
                  ,a.addr_hx_line1 as add_line_1 
                  ,a.addr_hx_line2 as add_line_2
                  ,a.city_hx as city
                  ,a.state
                  ,a.zip_hx as zip
                  ,a.county
                  ,r.disch_icd_1
		              ,r.disch_icd_2
		              ,r.adt_pat_class
		              ,department_id
		              ,department_name
		              ,g.X
		              ,g.Y
  FROM hpceclarity.bmi.readmissions r
		INNER JOIN hpceclarity.dbo.chmc_adt_addr_hx a
		  ON r.pat_id = a.pat_id
		LEFT JOIN temptable.dbo.full_list_geocode g
		  ON (a.addr_hx_line1 = g.add_line_1 
		      OR (a.addr_hx_line1 IS NULL AND g.add_line_1 IS NULL))
		    AND (a.addr_hx_line2 = g.add_line_2 
		        OR (a.addr_hx_line2 IS NULL AND g.add_line_2 IS NULL))
		    AND (a.city_hx = g.city OR (a.city_hx IS NULL AND g.city IS NULL))
		    AND (a.state = g.state OR (a.state IS NULL AND g.state IS NULL))
		    AND (a.zip_hx = g.zip OR (a.zip_hx IS NULL AND g.zip IS NULL))
  WHERE r.hosp_admsn_time >= a.eff_start_date
		AND (a.eff_end_date IS NULL OR r.hosp_admsn_time < a.eff_end_date)
		AND year(r.hosp_admsn_time) in ('2022', '2023')
		AND a.state IN ('Ohio', 'Indiana', 'Kentucky')
		AND g.foster != 1
    AND g.rmh != 1
    AND g.pobox != 1
    AND g.cchmc != 1
    AND g.stjoe != 1
    AND g.unknown_address != 1
    AND g.foreign_address != 1
                     ") |>
  mutate(
    Asthma = ifelse(
      disch_icd_1 %in% c(
        "J45.21",
        "J45.22", 
        "J45.31", 
        "J45.32", 
        "J45.41", 
        "J45.42", 
        "J45.51", 
        "J45.52", 
        "J45.901", 
        "J45.902" 
      ),
      1,
      0
    ),#<1>
    Diabetes = ifelse(
      disch_icd_1 %in% c(
        "E08.10", 
        "E10.10",
        "E10.11",
        "E10.65",
        "E10.9",
        "E11.10",
        "E11.649",
        "E11.65",
        "E11.69",
        "E11.9",
        "E13.10",
        "E13.65",
        "E15",
        "E16.1",
        "E16.2",
        "R73.01",
        "R73.02",
        "R73.03",
        "R73.09"
      ),#<2>
      1,
      0
    ),
    MH = ifelse(department_id %in% c(
      20026290, 
      10401085,	
      10401086,	
      10401087,	
      10401088,	
      10401089,	
      10401090,	
      10401091,	
      10401092,	
      10401093,	
      10401094
    ) | str_starts(disch_icd_1, "F") | str_starts(disch_icd_1, "R45"),
    1,
    0
    )
  ) |>
  left_join(asthma_exceptions) |>
  mutate(
    AsthmaException = coalesce(AsthmaException, 0),
    Asthma = ifelse(Asthma == 1 & AsthmaException == 0, 1, 0),
    county = str_to_title(county)
  )

```

1.  Diagnosis codes from [C2D2](https://c2d2.cchmc.org/article/552/).
2.  Diagnosis codes from [C2D2](https://c2d2.cchmc.org/article/1307/).

## Geocoding

In order to associate patients on a registry or hospital admissions with a neighborhood, the addresses associated with them must be geocoded. For registry patients, the most recent available address is used. For admissions, it is the address associated with the date of the admission.

The first step is selecting the addresses for which geographic coordinates have not already been determined. The addresses are then prepared for the DeGAUSS geocoding app and output as a .csv file.

```{r}
#| message: false
to_geocode <- filter(registry, is.na(X)) |>
  select(add_line_1:zip) |>
  rbind(filter(admits, is.na(X)) |> select(add_line_1:zip)) |>
  unique() |> 
  mutate(
    state = case_when(
      state == "Ohio" ~ "OH",
      state == "Kentucky" ~ "KY",
      TRUE ~ "IN"
    ),
    address = paste(add_line_1, city, state, sep = ", "),
    address = paste(address, zip),
    ID = row_number()
  ) |>
  select(ID, address)

#write_csv(to_geocode, "for_degauss.csv")
#docker run --rm -v ${PWD}:/tmp ghcr.io/degauss-org/geocoder:3.0.2 for_degauss.csv#<1>
```

1.  This command, entered into the command line in Windows Powershell, runs the DeGAUSS geocoder.

DeGAUSS determines the latitude and longitude coordinates for the entered addresses, excluding addresses known to belong to Cincinnati-area institutions (such as 222 E. Central Pkwy, the address of Hamilton County Children Services).

Placing these coordinates within a particular municipality or neighborhood requires creating a data frame with the boundaries of the areas. Merging the coordinates with these data frames will place the point within a municipality or neighborhood.

```{r}
#| message: false
#| warning: false
library(sf)
muni_lines <- oki_muni |>
  mutate(
    County = case_when(
      Municipality == "Loveland" ~ "Hamilton",
      Municipality == "Milford" ~ "Clermont",
      Municipality == "Fairfield" ~ "Butler",
      TRUE ~ County
    )
  ) |>
  group_by(Municipality, County) |>
  summarise(geometry = st_union(geometry)) |>
  st_as_sf()
```

Cincinnati neighborhood boundaries are obtained using the [cincy](https://geomarker.io/cincy/) library. The Statistical Neighborhood Approximation data set it used because we are using Census data, and these boundaries are drawn to coincide with Census block groups.

```{r}
#| message: false
library(cincy)

hood_lines <- neigh_sna |>
  rename(Neighborhood = neighborhood) |>
  mutate(
    Neighborhood = case_when(
      Neighborhood == "Villages at Roll Hill" ~ "Roll Hill",
      Neighborhood %in% c("Lower Price Hill", "Queensgate") ~ 
        "Lower Price Hill-Queensgate",
      Neighborhood == "North Avondale - Paddock Hills" ~
        "North Avondale-Paddock Hills",
      TRUE ~ Neighborhood
    ),
    Municipality = "Cincinnati"
  ) |>
  group_by(Municipality, Neighborhood) |>
  summarise(geometry = st_union(SHAPE)) |>
  mutate(geometry = st_transform(geometry, crs = "NAD83"))

geocoded1 <- filter(registry, !is.na(X)) |>
  select(X, Y) |>
  rbind(filter(admits, !is.na(X)) |> select(X, Y)) |>
  unique() 

geocoded <- read.csv("for_degauss_geocoded_v3.0.2.csv") |>
  filter(
    precision == "range",
    geocode_result != "imprecise_geocode"
  ) |>
  rename(X = lon, Y = lat) |>
  select(X, Y) |>
  rbind(geocoded1) |>
  unique() |>
  mutate(GeocodeID = row_number()) |>
  st_as_sf(coords = c("X", "Y"), crs = 'NAD83', remove = FALSE) |>
  st_join(muni_lines) |>
  filter(!is.na(Municipality)) |>
  group_by(GeocodeID) |>
  mutate(count = n()) |>
  filter(count == 1) |>#<1>
  select(-count)
```

1.  Addresses that are very near a boundary line sometimes are placed in more than one neighborhood. Because there is no easy way to determine the neighborhood for those few addresses, they are removed and the neighborhood considered unknown.

For addresses matched to municipalities other than Cincinnati, the process is complete. Addresses placed in Cincinnati are merged with the neighborhood lines to determine a neighborhood.

```{r}
#| message: false
cinci <- filter(geocoded, Municipality == "Cincinnati") |>
  select(-Municipality) |>
  st_join(hood_lines) |>
  filter(!is.na(Neighborhood))

hooded <- geocoded |>
  mutate(Neighborhood = Municipality) |>
  filter(Municipality != "Cincinnati") |>
  rbind(cinci)
```

With neighborhoods determined for as many addresses as possible, the addresses are matched back to patients. Patients on the registries, hospital admissions and patient admissions can then be totaled by neighborhood.

```{r}
#| message: false
registry_totals <- registry |>
  inner_join(hooded) |>
  distinct(pat_id, registry_name, County, Municipality, Neighborhood) |>
  group_by(County, Municipality, Neighborhood, registry_name) |>
  summarise(Patients = n()) |>
  separate_wider_delim(
    cols = registry_name,
    names = c("x", "Disease", "y"),
    delim = " "
  ) |>
  mutate(
    Disease = str_to_title(Disease),
    Disease = paste(Disease, "Registry", sep = "_")
  ) |>
  pivot_wider(
    id_cols = c(County, Municipality, Neighborhood),
    names_from = Disease,
    values_from = Patients,
    values_fill = 0
  )

admit_totals <- inner_join(admits, hooded) |>
  mutate(Year = year(contact_date)) |>
  distinct(
    pat_id, 
    pat_enc_csn_id, 
    Year,
    County, 
    Municipality, 
    Neighborhood,
    Asthma,
    Diabetes,
    MH
  ) |>
  group_by(County, Municipality, Neighborhood, Year) |>
  summarise(
    Asthma_Admits = sum(Asthma),
    Asthma_Admitted = length(unique(pat_id[Asthma == 1])),
    Diabetes_Admits = sum(Diabetes),
    Diabetes_Admitted = length(unique(pat_id[Diabetes == 1])),
    MH_Admits = sum(MH),
    MH_Admitted = length(unique(pat_id[MH == 1])),
    Total_Admits = n(),
    Total_Admitted = length(unique(pat_id))
  ) |>
  mutate(across(Asthma_Admits:Total_Admitted, \(x) coalesce(x, 0))) |>
  group_by(County, Municipality, Neighborhood) |>
  summarise(across(Asthma_Admits:Total_Admitted, mean))

hospital <- full_join(admit_totals, registry_totals) |>
  mutate(across(Asthma_Admits:Diabetes_Registry, \(x) coalesce(x, 0)))

cinci_hospital <- filter(hospital, Municipality == "Cincinnati") |> #<1>
  group_by(County, Municipality) |>#<1>
  summarise(across(Asthma_Admits:Diabetes_Registry, sum)) |>#<1>
  mutate(Neighborhood = "Cincinnati")#<1>
```

1.  Totals all Cincinnati neighborhoods.

To establish rates per 100 children, the number of children per neighborhood is estimated using the ACS age and gender data. The annual rates are determined using the averages of two years of data.

```{r}
#| message: false
children <- filter(
  hood_muni, 
  Group3 %in% c(
    "Under 5 years",
    "5 to 9 years",
    "10 to 14 years",
    "15 to 17 years"
  )
) |>
  group_by(County, Municipality, Neighborhood) |>
  summarise(Children = sum(estimate))

hospital_children <- rbind(hospital, cinci_hospital) |>
  inner_join(children) |>
  pivot_longer(
    cols = Asthma_Admits:Diabetes_Registry,
    names_to = "Measure"
  ) |>
  mutate(
    Rate = value*100/Children,
    Rate = ifelse(is.infinite(Rate), NA, Rate)
  ) |>
  separate_wider_delim(
    Measure,
    delim = "_",
    names = c("Condition", "Measure")
  )
```

```{r}
#| echo: false
#| tbl-cap: "Children per neighborhood"
head(children)
```

Next, the minimum, maximum and average rates are determined for the health metrics.

```{r}
#| message: false
hospital_means <- ungroup(hospital_children) |>
  filter(Municipality == Neighborhood) |>
  group_by(Condition, Measure) |>
  summarise(value = sum(value)) |>
  cross_join(
    filter(children, Neighborhood == Municipality) |> 
      ungroup() |> 
      summarise(Children = sum(Children))
  ) |>
  mutate(Mean = 100*value/Children) |>
  select(Condition, Measure, Mean)

hospital_rates <- ungroup(hospital_children) |>
  group_by(Condition, Measure) |>
  summarise(
    Min = min(Rate, na.rm = TRUE),
    Max = max(Rate, na.rm = TRUE),
    SD = sd(Rate, na.rm = TRUE)
  ) |>
  inner_join(hospital_means)

hospital_all <- inner_join(hospital_children, hospital_rates) |>
  mutate(
    Rate = ifelse(is.nan(Rate), NA, Rate),
    Shade = (Rate-Mean)/SD
  ) |>
  inner_join(areas)
```

```{r}
#| echo: false
#| tbl-cap: "Registry and admission data"
head(hospital_all)
```

With that, the data set is ready for graphing. The four plots for asthma, diabetes, psychiatric and total admissions are combined into one image using the cowplot package.

## Hospital admissions

```{r}
#| echo: false
#| message: false
library(cowplot)
admit_graph <- function(k){
  x <- hospital_all |>
    filter(
      HoodID == k,
      Condition == "Total"
    ) |>
    mutate(
      Measure = factor(Measure, levels = c("Admits", "Admitted")),
      Textloc = ifelse(Rate > 13, Rate - 1.5, Rate + 1.5)
    )
  
  shadelimits <- c(
    min(hospital_all$Shade[hospital_all$Condition == "Total"]), 
    max(hospital_all$Shade[hospital_all$Condition == "Total"])
  )
  
  ggplot(x, aes(x = Measure, y = Rate, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(
      x = NULL, 
      y = "Per 100 children per year (2022-23)", 
      title = "Total",
      fill = NULL
      ) +
      scale_y_continuous(limits = c(0, 17), breaks = seq(0, 16, 2)) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = .5)) + 
      geom_text(aes(label = round(Rate, 1), y = Textloc), size = 4) +
      geom_text(
        aes(
          label = ifelse(
            value > 0, 
            paste("n =", format(value, big.mark = ","), "per year"), 
            ""
            ), 
          y = ifelse(Rate > 13, Textloc - 2, Textloc + 2)
        ),
        size = 4
      ) +
      scale_fill_gradient2(
        limits = shadelimits, 
        high = cchmcdarkpurple, 
        low = cchmcdarkgreen, 
        mid = cchmclightblue,
        midpoint = 0,
        breaks = sort(c(shadelimits, mean(shadelimits))),
        labels = c("Lowest", "", "Highest")
      ) +
      scale_x_discrete(labels = c("Admissions", "Patients\nAdmitted")) 
}

asthma_admit_graph <- function(k){
  x <- hospital_all |>
    filter(
      HoodID == k,
      Condition == "Asthma",
      Measure != "Registry"
      ) |>
    mutate(
      Measure = factor(Measure, levels = c("Admits", "Admitted")),
      Textloc = ifelse(Rate > 2.5, Rate - .2, Rate + .2)
    )
  
  shadelimits <- c(
    min(
      hospital_all$Shade[hospital_all$Condition == "Asthma" & 
                           hospital_all$Measure != "Registry"]
      ),
    max(
      hospital_all$Shade[hospital_all$Condition == "Asthma" & 
                           hospital_all$Measure != "Registry"]
      )
    )

  ggplot(x, aes(x = Measure, y = Rate, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(
      x = NULL, 
      y = "Per 100 children per year (2022-23)", 
      title = "Asthma",
      fill = NULL
      ) +
    scale_y_continuous(limits = c(0, 3)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(aes(label = round(Rate, 1), y = Textloc), size = 4) +
    geom_text(
      aes(
        label = ifelse(
          value > 0, 
          paste("n =", format(value, big.mark = ","), "per year"), 
          ""
        ), 
        y = ifelse(Rate > 2.5, Textloc - .3, Textloc + .3)
      ),
      size = 4
    ) +
    scale_fill_gradient2(
      limits = shadelimits, 
      high = cchmcdarkpurple, 
      low = cchmcdarkgreen, 
      mid = cchmclightblue,
      midpoint = 0,
      breaks = sort(c(shadelimits, mean(shadelimits))),
      labels = c("Lowest", "", "Highest")
    ) +
    scale_x_discrete(labels = c("Admissions", "Patients\nAdmitted"))
}

diabetes_admit_graph <- function(k){
  x <- hospital_all |>
    filter(
      HoodID == k,
      Condition == "Diabetes",
      Measure != "Registry"
      ) |>
    mutate(
      Measure = factor(Measure, levels = c("Admits", "Admitted")),
      Textloc = ifelse(Rate > 4, Rate - .3, Rate + .3)
    )
  
  shadelimits <- c(
    min(
      hospital_all$Shade[hospital_all$Condition=="Diabetes" & 
                           hospital_all$Measure != "Registry"]
    ),
    max(
      hospital_all$Shade[hospital_all$Condition == "Diabetes" &
                           hospital_all$Measure != "Registry"]
    )
  )
  
  ggplot(x, aes(x = Measure, y = Rate, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(
      x = NULL, 
      y = "Per 100 children per year (2022-23)", 
      title = "Diabetes",
      fill = NULL
      ) +
      scale_y_continuous(limits = c(0, 5)) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = .5)) + 
      geom_text(aes(label = round(Rate, 1), y = Textloc), size = 4) +
      geom_text(
        aes(
          label = ifelse(value > 0, paste("n =", value, "per year"), ""), 
          y = ifelse(Rate > 4, Textloc - .4, Textloc + .4)
        ),
        size = 4
      ) +
      scale_fill_gradient2(
        limits = shadelimits, 
        high = cchmcdarkpurple, 
        low = cchmcdarkgreen, 
        mid = cchmclightblue,
        midpoint = 0,
        breaks = sort(c(shadelimits, mean(shadelimits))),
        labels = c("Lowest", "", "Highest")
      ) +
      scale_x_discrete(labels = c("Admissions", "Patients\nAdmitted"))
}

mh_graph <- function(k){
  x <- hospital_all |>
    filter(
      HoodID == k,
      Condition == "MH"
      ) |>
    mutate(
      Measure = factor(Measure, levels = c("Admits", "Admitted")),
      Textloc = ifelse(Rate > 3, Rate - .3, Rate + .3)
    )
  
  shadelimits <- c(
    min(hospital_all$Shade[hospital_all$Condition == "MH"]),
    max(hospital_all$Shade[hospital_all$Condition == "MH"])
    )
  
  ggplot(x, aes(x = Measure, y = Rate, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(
      x = NULL, 
      y = "Per 100 children per year (2022-23)", 
      title = "Psychiatric",
      fill = NULL
      ) +
    scale_y_continuous(limits = c(0, 4)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(aes(label = round(Rate, 1), y = Textloc), size = 4) +
    geom_text(
      aes(
        label = ifelse(value > 0, paste("n =", value, "per year"), ""), 
        y = ifelse(Rate > 3, Textloc - .4, Textloc + .4)
        ),
      size = 4
      ) +
    scale_fill_gradient2(
      limits = shadelimits, 
      high = cchmcdarkpurple, 
      mid = cchmclightblue,
      low = cchmcdarkgreen,
      midpoint = 0,
      breaks = sort(c(shadelimits, mean(shadelimits))),
      labels = c("Lowest", "", "Highest")
      ) +
    scale_x_discrete(labels = c("Admissions", "Patients\nAdmitted"))
}

admit_grid <- function(k){
  p1 <- admit_graph(k) + theme(legend.position = "none")
  p2 <- asthma_admit_graph(k) + theme(legend.position = "none")
  p3 <- diabetes_admit_graph(k) + theme(legend.position = "none")
  p4 <- mh_graph(k) + theme(legend.position = "none")
  plots <- plot_grid(p1, p2, p3, p4, ncol = 2)
  title <- ggdraw() +
    draw_label(areas$Neighborhood[areas$HoodID == k])
  legend <- get_legend(p1 + theme(legend.position = "bottom"))
  plot_grid(title, plots, legend, ncol = 1, rel_heights = c(0.08, 1, .1))
}

admit_popup_muni <- lapply((muninums), function(k) {
  admit_grid(k)
})

admit_popup_hood <- lapply((hoodnums), function(k) {
  admit_grid(k)
})

```

```{r}
#| echo: false
#| fig-cap: "Hospital admissions"
admit_popup_hood[[36]]
```

## Health registries

```{r}
#| echo: false
#| warning: false
library(glue)
registry_graph <- function(k){
  x <- hospital_all |>
    filter(
      Measure == "Registry",
      HoodID == k
      ) |>
    mutate(Textloc = ifelse(Rate > 38, Rate - 1, Rate + 1))
  
  shadelimits <- c(
    min(hospital_all$Shade[hospital_all$Measure == "Registry"]),
    max(hospital_all$Shade[hospital_all$Condition == "MH"])
  )
  
  ggplot(x, aes(x = Condition, y = Rate, fill = Shade)) +
    geom_bar(stat = "identity", color = "black") +
    labs(
      x = NULL, 
      y = glue("Per 100 children (as of ", {format(today(), "%b %d, %Y")}, ")"), 
      title = unique(x$Neighborhood),
      fill = NULL
    ) +
    scale_y_continuous(limits = c(0, 40)) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = .5)) + 
    geom_text(aes(label = round(Rate, 1), y = Textloc), size = 4) +
    geom_text(
      aes(
        label = ifelse(
          value > 0, 
          paste("n =", format(value, big.mark = ",")), 
          ""
          ), 
        y = ifelse(Rate > 38, Textloc - 2, Textloc + 2)
      ),
      size = 4
    ) +
    scale_fill_gradient2(
      limits = shadelimits, 
      high = cchmcdarkpurple, 
      mid = cchmclightblue,
      low = cchmcdarkgreen,
      midpoint = 0,
      breaks = sort(c(shadelimits, mean(shadelimits))),
      labels = c("Lowest", "", "Highest")
    )
}

registry_popup_muni <- lapply((muninums), function(k){
  registry_graph(k)
})

registry_popup_hood <- lapply((hoodnums), function(k){
  registry_graph(k)
})
```

```{r}
#| echo: false
#| fig-cap: "Health registries"
registry_popup_muni[[65]]
```

# Schools and Pharmacies

First, a list of Cincinnati Public Schools and their addresses is read in and cleaned. The district office and online-only schools are omitted.

```{r}
#| warning: false
#| message: false
schools <- read_delim("cps.txt", delim = " ")

colnames(schools) <- c(LETTERS[1:5], LETTERS[7:13])

schools2 <- schools |>
  mutate(
    Num1 = parse_number(C),
    Num2 = parse_number(D),
    Num3 = parse_number(E),
    Num4 = parse_number(G),
    Num5 = parse_number(H),
    Num6 = parse_number(I),
    Num7 = parse_number(J),
    Number = coalesce(Num1, Num2),
    Number = coalesce(Number, Num3),
    Number = coalesce(Number, Num4),
    Number = coalesce(Number, Num5),
    Number = coalesce(Number, Num6),
    Number = coalesce(Number, Num7),
    Number = ifelse(B == "Promise", "5425", Number),
    Name = paste(A, B),
    Name = ifelse(C == Number, Name, paste(Name, C)),
    Name = ifelse(Number == C | Number == D, Name, paste(Name, D)),
    Name  = ifelse(
      Number == C | Number == D | Number == E,
      Name,
      paste(Name, E)
    ),
    Name  = ifelse(
      Number == C | Number == D | Number == E | Number == G,
      Name,
      paste(Name, G)
    ),
    Name  = ifelse(
      Number == C | Number == D | Number == E | Number == G | Number == H,
      Name,
      paste(Name, H)
    ),
    Combo = paste(A, B, C, D, E, G, H, I, J, K, L, M),
    Combo = str_remove(Combo, Name),
    Combo = str_remove(Combo, Number),
    Combo = str_trim(Combo)
  ) |>
  separate_wider_delim(
    Combo, 
    delim = ",", 
    names = c("Street", "City", "Rest"), 
    too_few = "align_start"
  ) |>
  mutate(Rest = str_trim(Rest)) |>
  separate_wider_delim(
    Rest, 
    delim = " ", 
    names = c("State", "Zip"), 
    too_many = "drop"
  ) |>
  mutate(
    City = "Cincinnati",
    State = "OH",
    Street = ifelse(B == "Promise", "Winton Ridge Lane", Street),
    Zip = ifelse(Name == "Mt. Washington School", "45230", Zip),
    Name = ifelse(B == "Promise", "The Promise Center", Name),
    Name = ifelse(
      str_detect(Name, "Gamble Montessori Elementary"),
      "Gamble Montessori Elementary School",
      Name
    ),
    Name = ifelse(str_detect(Name, "Aiken"), "Aiken High School", Name)
  ) |>
  distinct(Name, Number, Street, City, State, Zip) |>
  filter(
    !Name %in% c(
      "Cincinnati Digital Academy", 
      "Virtual High School",
      "Hospital/Satellite Program Office"
    )
  ) |>
  mutate(
    Address = paste(Number, Street),
    Type = "School"
  ) |>
  select(-c(Street, Number))
```

```{r}
#| echo: false
#| tbl-cap: "Cincinnati Public School addresses"
head(schools2)
```

Next, a list of pharmacies and their addresses is read in. These pharmacies represent those used by CCHMC patients in the past 12 months.

```{r}
#| message: false
#| warning: false
library(readxl)
pharms <- read_excel("pharmacies.xlsx")

to_geocode <- pharms |>
  separate_wider_delim(
    pharmacy_name, 
    delim = "-", 
    names = c("Name", "name2", "name3"), 
    too_many = "merge",
    too_few = "align_start"
  ) |>
  mutate(
    name2 = ifelse(name2 == "", name3, name2),
    comma = str_detect(name2, ","),
    city = str_trim(ifelse(comma, name2, name3))
  ) |>
  separate_wider_delim(
    city,
    delim = "-",
    names = c("city", "add", "add2", "add3"),
    too_few = "align_start",
    too_many = "merge"
  ) |>
  mutate(
    comma = str_detect(city, ","),
    city = ifelse(comma, city, str_trim(add)),
    comma = str_detect(city, ","),
    city = ifelse(comma, city, str_trim(add2)),
    comma = str_detect(city, ",")
    ) |>
  filter(comma) |>
  separate_wider_delim(
    city,
    delim = ",",
    names = c("city", "state", "state2", "state3"),
    too_few = "align_start"
  ) |>
  mutate(
    state = case_when(
      !is.na(state3) ~ state3,
      !is.na(state2) ~ state2,
      TRUE ~ state
    ),
    state = str_trim(state),
    length = str_length(state)
  ) |>
  filter(
    length == 2,
    state %in% c("OH", "KY", "IN")
  ) |>
  mutate(
    add3 = ifelse(str_detect(add3, "NON E-RX"), NA, str_trim(add3))
  ) |>
  separate_wider_delim(
    add2, 
    names = "add2", 
    delim = "SUITE", 
    too_many = "drop"
    ) |>
  separate_wider_delim(add3, names = "add3", delim = ",", too_many = "drop") |>
  separate_wider_delim(add2, names = "add2", delim = " STE", too_many = "drop") |>
  separate_wider_delim(add2, names = "add2", delim = " ROOM", too_many = "drop") |>
  separate_wider_delim(add2, names = "add2", delim = " PO ", too_many = "drop") |>
  separate_wider_delim(add2, names = "add2", delim = " RM ", too_many = "drop") |> 
  mutate(
    add2 = str_trim(add2),
    add = ifelse(
      str_trunc(add2, 1, "right", ellipsis = "") %in% 1:9 | is.na(add2), 
      add, 
      paste(add, add2, sep = " ")
      ),
    add2 = ifelse(
      !str_trunc(add2, 1, "right", ellipsis = "") %in% 1:9, 
      NA, 
      add2
      ),
    add2 = ifelse(str_length(add2) < 4, NA, add2),
    add = ifelse(!is.na(add2), NA, str_trim(add)),
    add = coalesce(add3, add),
    add = coalesce(add2, add),
    add = coalesce(add, name3)
    ) |>
  separate_wider_delim(add, names = "add", delim = " AT ", too_many = "drop") |>
  separate_wider_delim(add, names = "add", delim = " STE", too_many = "drop") |>
  separate_wider_delim(add, names = "add", delim = " SUITE ", too_many = "drop") |>
  mutate(
    add = str_trim(add),
    Zip = NA,
    Type = "Pharmacy"
    ) |>
  select(Name, add, city, state, Zip, Type) |>
  rename(
    Address = add,
    City = city,
    State = state
    ) |>
  rbind(schools2)
```

The addresses are geocoded through the Census Bureau API using the tidygeocoder package.

```{r}
#| message: false
#| warning: false 
library(tidygeocoder)
geocoded_points <- geocode(
  to_geocode,
  street = Address,
  city = City,
  state = State,
  postalcode = Zip,
  method = "census"
) 
```

```{r}
#| echo: false
#| tbl-cap: "Geocoded pharmacy and school addresses"
head(geocoded_points)
```

Because the CCHMC pharmacy address records lack Zip codes, the Census geocoder is unable to locate many of them. Those that are missed will be attempted a second time using the Geoapify platform API. This method finds more addresses than the Census API, but is also much slower.

```{r}
#| message = FALSE
undone <- filter(geocoded_points, is.na(lat)) |>
  select(-c(lat, long)) |>
  geocode(
    street = Address,
    city = City,
    state = State,
    postalcode = Zip,
    method = "geoapify"
  )
```

The latitude and longitude coordinates determined by the geocoders are added to those for the school buildings, then matched with the county subdivision boundaries to determine which pharmacies are in Cincinnati and which are in the eight-county area.

```{r}
#| message: false
points_all <- undone |>
  select(Name, Type, lat, long, Address) |>
  rbind(select(geocoded_points, Name, lat, long, Type, Address)) |>
  filter(!is.na(lat))

points_all2 <- points_all |>
  st_as_sf(coords = c("long", "lat"), crs = "NAD83") |>
  inner_join(points_all, multiple = "all") |>
  unique()

points <- muni_lines |>
  st_join(points_all2, left = FALSE)

cinci_points <- filter(
  points, 
  Municipality %in% c("Cincinnati", "Norwood", "St. Bernard", "Elmwood Place") | 
    Type == "School"
)
```

# Mapping

With all the graphs created and schools and pharmacies located, the next step is to create the city map. Each neighborhood is placed into one of five tiers based on its Deprivation Index, and the centroid of each neighborhood is calculated so that a marker can be placed there. Norwood, St. Bernard and Elmwood Place are added because they are surrounded by Cincinnati.

```{r}
#| message: false
map_lines <- muni_lines |> 
  mutate(Neighborhood = Municipality) |>
  rbind(hood_lines |> mutate(County = "Hamilton")) |>
  inner_join(di_rates) |>
  inner_join(areas) |>
  mutate(
    Tier = case_when(
      value >= .6 ~ "Highest",
      value >= .475 ~ "Higher",
      value >= .35 ~ "Medium",
      value >= .225 ~ "Lower",
      TRUE ~ "Lowest"
    ),
    Tier = factor(
      Tier, 
      levels = c("Lowest", "Lower", "Medium", "Higher", "Highest")
    ),
    Centroid = st_centroid(geometry)
  ) |>
  arrange(HoodID) |>
  select(geometry, Neighborhood, Municipality, Tier, Centroid, HoodID)

centroids <- st_coordinates(map_lines$Centroid) |>
  as_tibble() |>
  mutate(
    Neighborhood = map_lines$Neighborhood,
    X = case_when(
      Neighborhood == "Sycamore Township" ~ -84.3788,#<1>
      Neighborhood == "Columbia Township" ~ -84.40098,#<1>
      TRUE ~ X
    ),
    Y = case_when(
      Neighborhood == "Sycamore Township" ~ 39.20386,#<1>
      Neighborhood == "Columbia Township" ~ 39.17114,#<1>
      Neighborhood == "East End" ~ 39.122,#<1>
      Neighborhood == "Riverside" ~ 39.07735,#<1>
      TRUE ~ Y
    ),
    HoodID = map_lines$HoodID
  ) |>
  st_as_sf(coords = c("X", "Y"), crs = "NAD83") |>
  rename(Centroid = geometry)

map_lines <- as_tibble(select(map_lines, -Centroid)) |>
  inner_join(as_tibble(centroids)) |>
  st_as_sf()

cinci_map_lines <- map_lines |>
  filter(Neighborhood != Municipality |
           Municipality %in% c("Norwood", "St. Bernard", "Elmwood Place")
  )

muni_map_lines <- filter(map_lines, Neighborhood == Municipality)
```

1.  Because some neighborhoods have irregular shapes, their centroids need to be moved to fall within the shape on the map.

Next, color palettes for the map and a set of icons for the schools and pharmacies are created.

```{r}
#| warning: false
#| message: false
library(leaflet)
cchmclightgreen <- "#A1CA3C"
cchmclightpurple <- "#CA5699"
pal <- colorFactor(
  c(
    cchmcdarkgreen, 
    cchmclightgreen, 
    cchmclightblue, 
    cchmclightpurple, 
    cchmcdarkpurple
  ), 
  domain = map_lines$Tier
)

muni_icons <- icons(
  iconUrl = ifelse(
    points$Type == "School", 
    "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
    "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png"
  ),
  iconWidth = 20,
  iconHeight = 30
)

cinci_icons <- icons(
  iconUrl = ifelse(
    cinci_points$Type == "School", 
    "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
    "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png"
  ),
  iconWidth = 20,
  iconHeight = 30
)
```

Finally, city neighborhood map is created using the leaflet, leaflegend and leafpop packages and saved using the htmlwidgets package.

```{r}
#| warning: false
library(htmlwidgets)
library(leaflegend)
library(leafpop)

city_map <- leaflet() |>
  addTiles() |>
  addPolygons(
    data = cinci_map_lines,
    stroke = TRUE,
    weight = 1,
    smoothFactor = .5,
    opacity = 1,
    fillOpacity = .7,
    fillColor = ~pal(Tier)
  ) |>
  addLegendFactor(
    pal = pal,
    values = cinci_map_lines$Tier,
    title = "Deprivation Index",
    position = "topleft"
  ) |>
  addLayersControl(
    baseGroups = c(
      "Demographics", 
      "Deprivation indicators",
      "Age and gender",
      "Household types",
      "Geographic mobility",
      "Hospital admissions",
      "Medical registries",
      "Schools and pharmacies"
    ),
    position = "bottomleft",
    options = layersControlOptions(collapsed = FALSE)
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(demo_popup_hood, height = 300, width = 700),
    group = "Demographics"
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(di_popup_hood, height = 300, width = 700),
    group = "Deprivation indicators"
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(pyr_popup_hood, height = 300, width = 700),
    group = "Age and gender"
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(hh_popup_hood, height = 300, width = 700),
    group = "Household types"
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(mobile_popup_hood, height = 300, width = 700),
    group = "Geographic mobility"
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(admit_popup_hood, height = 500, width = 700),
    group = "Hospital admissions"
  ) |>
  addCircleMarkers(
    data = cinci_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(registry_popup_hood, height = 300, width = 600),
    group = "Health registries"
  ) |>
  addMarkers(
    data = cinci_points,
    ~long,
    ~lat,
    icon = cinci_icons,
    popup = ~Name,
    group = "Schools and pharmacies"
  ) 

#saveWidget(city_map, "city map.html")
```

```{r}
#| echo: false
#| fig-cap: "Cincinnati neighborhood map"
city_map
```

The process is repeated for the eight-county municipality map.

```{r}
#| warning: false
muni_map <- leaflet() |>
  addTiles() |>
  addPolygons(
    data = muni_map_lines,
    stroke = TRUE,
    weight = 1,
    smoothFactor = .5,
    opacity = 1,
    fillOpacity = .7,
    fillColor = ~pal(Tier)
  ) |>
  addLegendFactor(
    pal = pal,
    values = muni_map_lines$Tier,
    title = "Deprivation Index",
    position = "topleft"
  ) |>
  addLayersControl(
    baseGroups = c(
      "Demographics", 
      "Deprivation indicators",
      "Age and gender",
      "Household types",
      "Geographic mobility",
      "Hospital admissions",
      "Medical registries",
      "Schools and pharmacies"
    ),
    position = "bottomleft",
    options = layersControlOptions(collapsed = FALSE)
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(demo_popup_muni, height = 300, width = 700),
    group = "Demographics"
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(di_popup_muni, height = 300, width = 700),
    group = "Deprivation indicators"
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(pyr_popup_muni, height = 300, width = 700),
    group = "Age and gender"
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(hh_popup_muni, height = 300, width = 700),
    group = "Household types"
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(mobile_popup_muni, height = 300, width = 700),
    group = "Geographic mobility"
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(admit_popup_muni, height = 500, width = 700),
    group = "Hospital admissions"
  ) |>
  addCircleMarkers(
    data = muni_map_lines$Centroid,
    color = cchmcpink,
    stroke = FALSE,
    fillOpacity = 1,
    radius = 4,
    popup = popupGraph(registry_popup_muni, height = 300, width = 700),
    group = "Medical registries"
  ) |>
  addMarkers(
    data = points,
    ~long,
    ~lat,
    icon = muni_icons,
    popup = ~Name,
    group = "Schools and pharmacies"
  ) 

#saveWidget(muni_map, "area map.html")
```

```{r}
#| echo: false
#| fig-cap: "Eight-county municipality map"
muni_map
```
