---
title: "neighborhood data repository"
author: "Aaron Flicker"
format: 
  html:
    link-external-newwindow: true
    df-print: paged
editor: visual
---

# Data to input

First is a list of deprivation indexes for every census tract in the United States.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(tidycensus)
library(odbc)
library(DBI)
library(readxl)
library(tidygeocoder)
library(tigris)
library(sf)
library(tigris)
library(leaflet)
library(leafpop)
library(leaflegend)

## List of census tract deprivation indexes
di <- read.csv(
  "input data/deprivation index all tracts 2021.csv",
  colClasses = c("numeric", "character", rep("NULL", 6))
  )

```

```{r, echo=FALSE, message=FALSE}
head(di)
```

These are calculated based on the most recent available five-year Census American Community Survey data. As of this writing, that is for the years 2017-21.

The crosswalk between census tracts and Cincinnati neighborhoods. This is derived from the city's [Statistical Neighborhood Approximations](https://www.cincinnati-oh.gov/planning/maps-and-data/census-demographics/2020-census-data/), which define which census tracts and block groups between to each neighborhood, and the University of Missouri's [Census Data Center](https://mcdc.missouri.edu/applications/geocorr.html), which provides a crosswalk between census tracts and municipalities.

```{r}
allocations <- read.csv(
  "input data/neighborhood bg allocations.csv",
  colClasses = c(
    "character", 
    rep("NULL", 3), 
    "character", 
    "numeric", 
    "character"
    )
  )

```

```{r, echo=FALSE}
head(allocations)
```

Because the deprivation index is calculated only at the census tract level, the crosswalks allow us to estimate it for areas that cross tract lines.

The Missouri Census Data Center also is the source for a similar list linking census tracts to the municipalities in the eight-county Cincinnati area.

```{r}

oki <- read.csv(
  "input data/oki allocations.csv",
  col.names = c(
    "CountyCode",
    "Tract",
    NA,
    "County",
    "Municipality",
    NA,
    "Allocation"
  ),
  colClasses = c(
    "character", 
    "character", 
    "NULL", 
    "character", 
    "character", 
    "NULL", 
    "numeric"
    )
  ) |>
  filter(
    County %in% c(
    "Dearborn IN",
    "Boone KY",
    "Campbell KY",
    "Kenton KY",
    "Butler OH",
    "Clermont OH",
    "Hamilton OH",
    "Warren OH"
    )
    ) |>
  separate_wider_delim(
    Municipality, delim = "CCD", names = "Municipality", too_many = "drop"
    ) |>
  separate_wider_delim(
    Municipality, delim = " city", names = "Municipality", too_many = "drop"
  ) |>
  separate_wider_delim(
    Municipality, delim = ",", names = "Municipality", too_many = "drop"
  )|>
  separate_wider_delim(
    Municipality, delim = "village", names = "Municipality", too_many = "drop"
  ) |>
  separate_wider_delim(
    Tract, 
    delim = ".", 
    names = c("TractA", "TractB"),
    too_few = "align_start"
    ) |>
  mutate(
    Municipality = str_remove(Municipality, "The Village of"),
    Municipality = str_to_title(Municipality),
    Municipality = str_trim(Municipality),
    Tract = NA
    ) |>
  separate_wider_delim(County, delim = " ", names = c("County", "State")) |>
  mutate(
    State = case_when(
      State == "OH" ~ "Ohio",
      State == "KY" ~ "Kentucky",
      TRUE ~ "Indiana"
      ),
    TractB = coalesce(TractB, "")
    )

for (i in 1:nrow(oki)){
  if (str_length(oki$TractA[i]) < 4){
    prefix_length <- 4-str_length(oki$TractA[i])
    prefix <- str_flatten(rep("0", prefix_length))
  }else{
    prefix_length = 0
    prefix = ""
  }
  suffix_length <-
    6-prefix_length-str_length(oki$TractA[i])-str_length(oki$TractB[i])
  suffix <- str_flatten(rep("0", suffix_length))
  oki$Tract[i] <- paste0(prefix, oki$TractA[i], oki$TractB[i], suffix)
}
oki$GEOID <- paste0(oki$CountyCode, oki$Tract)

```

```{r, echo=FALSE}
head(select(oki, County:Allocation, GEOID))
```

# Census data

The census data itself can be downloaded directly to R Studio using the tidycensus package. We will download 62 specific variables, some of which will be combined into broader categories.

```{r}
vars <- load_variables(2021, "acs5")
bg_vars <- filter(vars, geography == "block group")
tract_vars <- filter(vars, geography == "tract") |>
  left_join(bg_vars, join_by(label, concept))

bg_var_list <-c(
  paste0("B01001_00", c(1, 3:6)),
  paste0("B01001_0", 27:30),
  paste0("B02001_00", 2:3),
  "B03002_012",
  paste0("B11005_00", 1:2),
  "B15003_001",
  paste0("B15003_0", 17:25),
  paste0("B16004_00", c(1, 3, 7, 8)),
  paste0("B16004_0", c(12, 13, 17, 18, 22, 23, 25, 29, 30, 34, 35, 39, 
                       40, 44, 45, 47, 51, 52, 56, 57, 61, 62, 66, 67)),
  paste0("B17010_00", 1:2),
  "B19049_001",
  paste0("B25002_00", c(1, 3)),
  paste0("B27010_0", c(17, 33, 50, 66))
  )

cat_frame <- data.frame(
  variable = sort(c(bg_var_list, "B19058_002")),
  category = c(
    "Population",
    rep("Children", 8),
    "White",
    "Black",
    "Hispanic",
    "Households",
    "HHWithChildren",
    "Age25",
    rep("HighSchool", 9),
    "Age5",
    "English",
    rep("LimitedEnglish", 8),
    "English",
    rep("LimitedEnglish", 8),
    "English",
    rep("LimitedEnglish", 8),
    "Families",
    "Poverty",
    "MedianHHIncome",
    "Assistance",
    "HousingUnits",
    "Vacant",
    rep("Uninsured", 4)
    )
  )
```

```{r, echo=FALSE}
head(inner_join(cat_frame, vars, by = c("variable" = "name")), 12)
```

First, the data is downloaded for Cincinnati neighborhoods. Because some of these neighborhoods cross census tract lines, the data is selected at the block group level.

```{r, message=FALSE}
hamco_bg <- get_acs(
  geography = "block group",
  variables = bg_var_list,
  county = "Hamilton",
  state = "OH"
  ) |>
  inner_join(cat_frame) |>
  group_by(GEOID, category) |>
  summarise(estimate = sum(estimate)) |>
  pivot_wider(
    id_cols = GEOID,
    names_from = category,
    values_from = estimate
  ) |>
  mutate(Income = MedianHHIncome*Households) |>
  inner_join(allocations, multiple = "all") |>
  mutate(across(c(Age25:LimitedEnglish, Population:Income), \(x) x*Allocation))
```

```{r, echo=FALSE}
head(hamco_bg)
```

Because some of the block groups cross city lines, the totals are prorated. For example, about 62% of block group 390610046023 is in Mt. Washington, with the rest in Anderson Township. To estimate the totals for Mt. Washington, the totals for this block group are multiplied by the share of it that is in Cincinnati.

The median household income must be handled differently because it is not a simple total. The neighborhood median income is estimated in the following manner:

1.  For each census block group for which income data are available, multiply the median household income by the number of households.

2.  Total this figure and the number of households at the neighborhood level.

3.  Divide the neighborhood income figure by the number of households in the neighborhood.

```{r}
hood_inc <- hamco_bg |>
  filter(
    Municipality == "Cincinnati",
    !is.na(Income)
    ) |>
  group_by(Neighborhood) |>
  summarise(
    Income = sum(Income),
    IncomeHH = sum(Households)
    )
```

```{r, echo=FALSE}
head(hood_inc)
```

This is essentially a weighted average of the median household income in the neighborhood's constituent block groups.

Next, all of the other categories are calculated at the neighborhood level.

```{r, message=FALSE}
cinci_hood <- filter(hamco_bg, Municipality == "Cincinnati") |>
  ungroup() |>
  select(Age25:LimitedEnglish, Population:White, Municipality, Neighborhood) |>
  group_by(Municipality, Neighborhood) |>
  summarise(across(Age25:White, sum)) |>
  left_join(hood_inc)
```

```{r, echo=FALSE}
head(cinci_hood)
```

One constituent element of the deprivation index -- the proportion of households that receive public assistance -- is not available at the block group level, so it must be estimated using tract-level data.

```{r, message=FALSE}
hh_tract <- filter(hamco_bg, Municipality == "Cincinnati") |>
  mutate(Tract = str_trunc(GEOID, 11, "right", ellipsis = "")) |>
  group_by(Tract, Neighborhood) |>
  summarise(Households = sum(Households)) |>
  group_by(Tract) |>
  mutate(
    TractHH = sum(Households),
    Allocation = Households/TractHH
    )

hood_assistance <- get_acs(
  geography = "tract",
  variables = "B19058_002",
  county = "Hamilton",
  state = "OH"
  ) |>
  inner_join(
    select(hh_tract, -Households), 
    by = c("GEOID" = "Tract"),
    multiple = "all"
    ) |>
  mutate(
    Assistance = estimate*Allocation,
    HH = TractHH*Allocation
    ) |>
  group_by(Neighborhood) |>
  summarise(Assistance = sum(Assistance))

cinci_hood <- inner_join(cinci_hood, hood_assistance) |>
  mutate(
    County = "Hamilton",
    State = "Ohio",
    across(Age25:Assistance, round)
    ) 
```

Next, the same data are downloaded at the county subdivision level for our eight counties of interest. Generally, county subdivisions are local government units. However, two municipalities in our region (Loveland and Milford) cross county lines. These municipalities will have multiple county subdivisions in the data set that must be combined to obtain municipal-level data.

```{r, message=FALSE}
oh_cs <- get_acs(
  geography = "county subdivision",
  variables = c(bg_var_list, "B19058_002"),
  state = "OH",
  county = c("Clermont", "Warren", "Butler", "Hamilton"),
  year = 2021
  )

ky_cs <- get_acs(
  geography = "county subdivision",
  variables = c(bg_var_list, "B19058_002"),
  state = "KY",
  county = c("Boone", "Campbell", "Kenton"),
  year = 2021
  )

in_cs <- get_acs(
  geography = "county subdivision",
  variables = c(bg_var_list, "B19058_002"),
  state = "IN",
  county = "Dearborn",
  year = 2021
  )

oki_cs <- rbind(oh_cs, ky_cs) |>
  rbind(in_cs) |>
  inner_join(cat_frame) |>
  separate_wider_delim(
    NAME, 
    delim = ", ", 
    names = c("Municipality", "County", "State")
    ) |>
  mutate(
    Municipality = str_remove(Municipality, " city"),
    Municipality = str_remove(Municipality, " village"),
    Municipality = str_remove(Municipality, " CCD"),
    Municipality = str_remove(Municipality, "The Village of "),
    Municipality = str_to_title(Municipality),
    County = str_remove(County, " County"),
    County = case_when(
      Municipality == "Loveland" ~ "Hamilton",
      Municipality == "Milford" ~ "Clermont",
      TRUE ~ County
    )
  ) |>
  filter(
    !is.na(estimate),
    estimate > 0
    )

oki_no_income <- filter(oki_cs, category != "MedianHHIncome") |>
  group_by(Municipality, County, State, category) |>
  summarise(estimate = sum(estimate)) |>
  pivot_wider(
    id_cols = c(Municipality, State, County),
    names_from = category,
    values_from = estimate
  ) |>
  mutate(
    across(c(Age25:LimitedEnglish, Population:White), \(x) coalesce(x, 0)),
    Neighborhood = NA
    )

oki_income <- filter(oki_cs, category %in% c("MedianHHIncome", "Households")) |>
  pivot_wider(
    id_cols = c(GEOID, Municipality, County, State),
    names_from = category,
    values_from = estimate
  ) |>
  mutate(Income = MedianHHIncome*Households) |>
  group_by(Municipality, County, State) |>
  summarise(
    Income = sum(Income),
    IncomeHH = sum(Households)
  ) |>
  inner_join(oki_no_income)
```

```{r, echo=FALSE}
head(oki_no_income)
```

The same data points are then downloaded at the county level for the eight county region. These are then totaled to obtain data for the eight-county metro area.

```{r, message=FALSE}
oh_county <- get_acs(
  geography = "county",
  variables = c(bg_var_list, "B19058_002"),
  state = "OH",
  county = c("Clermont", "Warren", "Butler", "Hamilton"),
  year = 2021
  )

ky_county <- get_acs(
  geography = "county",
  variables = c(bg_var_list, "B19058_002"),
  state = "KY",
  county = c("Campbell", "Kenton", "Boone"),
  year = 2021
  )

in_county <- get_acs(
  geography = "county",
  variables = c(bg_var_list, "B19058_002"),
  state = "IN",
  county = "Dearborn",
  year = 2021
  )

oki_county <- rbind(oh_county, ky_county) |>
  rbind(in_county) |>
  inner_join(cat_frame) |>
  separate_wider_delim(
    cols = NAME, 
    delim = ", ", 
    names = c("County", "State")
  ) |>
  mutate(County = str_remove(County, " County")) |>
  group_by(County, State, category) |>
  summarise(estimate = sum(estimate)) |>
  pivot_wider(
    id_cols = c(County, State), 
    names_from = category, 
    values_from = estimate
  ) |>
  mutate(
    Income = MedianHHIncome*Households,
    IncomeHH = Households,
    Municipality = NA,
    Neighborhood = NA
    ) |>
  select(-MedianHHIncome)

metro <- oki_county |>
  ungroup() |>
  summarise(across(Age25:IncomeHH, sum)) |>
  mutate(
    County = "All",
    State = "All",
    Municipality = NA,
    Neighborhood = NA
  )
```

```{r,echo=FALSE}
metro
```

Next, the deprivation index is estimated for each Cincinnati neighborhood. Because the deprivation index is calculated at the census tract level, the block group population data for Cincinnati must be rolled up to that level. The neighborhood's deprivation index is the average, weighted by population, of the deprivation indexes of its constituent census tracts.

```{r, message=FALSE}
hood_di <- filter(hamco_bg, Municipality == "Cincinnati") |>
  mutate(census_tract_fips = str_trunc(GEOID, 11, "right", ellipsis = "")) |>
  group_by(census_tract_fips, Neighborhood, Municipality) |>
  summarise(Population = sum(Population)) |>
  group_by(Municipality, Neighborhood) |>
  mutate(
    HoodPop = sum(Population),
    TractWeight = Population/HoodPop
  ) |>
  inner_join(di) |>
  mutate(DIWeight = TractWeight*dep_index) |>
  summarise(DeprivationIndex = sum(DIWeight)) |>
  mutate(
    County = "Hamilton",
    State = "Ohio"
  )
```

```{r, echo=FALSE}
head(hood_di)
```

To do the same for other counties in the area, the tract-level populations are are required.

```{r, message=FALSE}
oh_tract <- get_acs(
  geography = "tract",
  variables = "B01001_001",
  state = "OH",
  county = c("Clermont", "Warren", "Butler", "Hamilton"),
  year = 2021
  )

ky_tract <- get_acs(
  geography = "tract",
  variables = "B01001_001",
  state = "KY",
  county = c("Kenton", "Campbell", "Boone"),
  year = 2021
  )

in_tract <- get_acs(
  geography = "tract",
  variables = "B01001_001",
  state = "IN",
  county = c("Dearborn"),
  year = 2021
  )
```

Using the weighted average method, the deprivation index is then estimated for municipalities, counties, and the eight-county area as a whole.

```{r, message=FALSE}
cs_di <- rbind(oh_tract, ky_tract) |>
  rbind(in_tract) |>
  full_join(select(oki, County:Allocation, GEOID), multiple = "all") |>
  mutate(Population = estimate*Allocation) |>
  inner_join(
    select(di, census_tract_fips, dep_index), 
    by = c("GEOID" = "census_tract_fips")
    ) |>
  mutate(
    County = case_when(
      Municipality == "Loveland" ~ "Hamilton",
      Municipality == "Milford" ~ "Clermont",
      TRUE ~ County
    )
  ) |>
  group_by(Municipality, County, State) |>
  mutate(
    TownPop = sum(Population),
    TractShare = Population/TownPop,
    DIWeight = TractShare*dep_index
    ) |>
  summarise(DeprivationIndex = sum(DIWeight)) |>
  mutate(Neighborhood = NA)
```

```{r, echo=FALSE}
head(cs_di)
```

```{r, message=FALSE}
county_di <- select(oki_income, Municipality, County, State, Population) |>
  inner_join(cs_di) |>
  mutate(DIWeight = DeprivationIndex*Population) |>
  group_by(State, County) |>
  summarise(
    DIWeight = sum(DIWeight),
    Population = sum(Population)
  ) |>
  mutate(
    DeprivationIndex = DIWeight/Population,
    DIWeight = DeprivationIndex*Population,
    Municipality = NA,
    Neighborhood = NA
  ) |>
  select(-DIWeight)
```

```{r, echo=FALSE}
head(county_di)
```

```{r}
metro_di <- county_di |>
  mutate(DIWeight = DeprivationIndex*Population) |>
  ungroup() |>
  summarise(
    Population = sum(Population),
    DIWeight = sum(DIWeight)
    ) |>
  mutate(
    DeprivationIndex = DIWeight/Population,
    State = "All",
    County = "All",
    Municipality = NA,
    Neighborhood = NA
    ) |>
  select(DeprivationIndex:Neighborhood)
```

```{r, echo=FALSE}
metro_di
```

```{r, message=FALSE}
di_all <- rbind(hood_di, cs_di) |>
  rbind(select(county_di, -Population)) |>
  rbind(metro_di)

demo_all <- rbind(cinci_hood, oki_income) |>
  rbind(oki_county) |>
  ungroup() |>
  rbind(metro) |>
  inner_join(di_all) |>
  mutate(
    BlackRate = Black/Population,#<1>
    WhiteRate = White/Population,#<2>
    HispanicRate = Hispanic/Population,#<3>
    ChildRate = Children/Population,#<4>
    ChildHHRate = HHWithChildren/Households,#<5>
    OtherLanguage = Age5-English,#<6>
    OtherLanguageRate = OtherLanguage/Age5,#<6>
    LimitedEnglishRate = LimitedEnglish/Age5,#<7>
    UninsuredRate = Uninsured/Population,#<8>
    HighSchoolRate = HighSchool/Age25,#<9>
    AssistanceRate = Assistance/Households,#<10>
    PovertyRate = Poverty/Families,#<11>
    VacancyRate = Vacant/HousingUnits,#<12>
    MedianHHIncome = Income/IncomeHH#<13>
  ) |>
  select(
    State, County, Municipality, Neighborhood,
    Population, White, WhiteRate, Black, BlackRate, Hispanic, HispanicRate,
    Children, ChildRate, Uninsured, UninsuredRate,
    Households, HHWithChildren, ChildHHRate, Assistance, AssistanceRate, 
    MedianHHIncome,
    Age25, HighSchool, HighSchoolRate,
    Families, Poverty, PovertyRate,
    HousingUnits, Vacant, VacancyRate,
    Age5, OtherLanguage, OtherLanguageRate, LimitedEnglish, LimitedEnglishRate
    ) |>
  full_join(di_all)
```



1.  Proportion of population that is Black

2.  Proportion of population that is white

3.  Proportion of population that is Hispanic/Latino

4.  Proportion of population that is children under 18

5.  Proportion of households that include a child under 18

6.  Proportion of the population over age 5 that speaks a language other than English at home

7.  Proportion of the population over age 5 with no or limited English-speaking ability

8.  Proportion of the population that lacks health insurance

9.  Proportion of the population over age 25 with a high school diploma or equivalent

10. Proportion of households that receive public assistance

11. The poverty rate

12. The housing vacancy rate

13. The median household income

```{r, echo=FALSE}
head(demo_all)
```
